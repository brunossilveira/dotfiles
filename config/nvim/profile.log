SCRIPT  /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/filetype.lua
Sourced 1 time
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
                            if vim.g.did_load_filetypes then
                              return
                            end
                            vim.g.did_load_filetypes = 1
                            
                            vim.api.nvim_create_augroup('filetypedetect', { clear = false })
                            
                            vim.api.nvim_create_autocmd({ 'BufRead', 'BufNewFile', 'StdinReadPost' }, {
                              group = 'filetypedetect',
                              callback = function(args)
                                if not vim.api.nvim_buf_is_valid(args.buf) then
                                  return
                                end
                                local ft, on_detect = vim.filetype.match({
                                  -- The unexpanded file name is needed here. #27914
                                  -- Neither args.file nor args.match are guaranteed to be unexpanded.
                                  filename = vim.fn.bufname(args.buf),
                                  buf = args.buf,
                                })
                                if not ft then
                                  -- Generic configuration file used as fallback
                                  ft = require('vim.filetype.detect').conf(args.file, args.buf)
                                  if ft then
                                    vim.api.nvim_buf_call(args.buf, function()
                                      vim.api.nvim_cmd({ cmd = 'setf', args = { 'FALLBACK', ft } }, {})
                                    end)
                                  end
                                else
                                  -- on_detect is called before setting the filetype so that it can set any buffer local
                                  -- variables that may be used the filetype's ftplugin
                                  if on_detect then
                                    on_detect(args.buf)
                                  end
                            
                                  vim.api.nvim_buf_call(args.buf, function()
                                    vim.api.nvim_cmd({ cmd = 'setf', args = { ft } }, {})
                                  end)
                                end
                              end,
                            })
                            
                            -- These *must* be sourced after the autocommand above is created
                            if not vim.g.did_load_ftdetect then
                              vim.cmd([[
                              augroup filetypedetect
                              runtime! ftdetect/*.{vim,lua}
                              augroup END
                              ]])
                            end
                            
                            -- Set up the autocmd for user scripts.vim
                            vim.api.nvim_create_autocmd({ 'BufRead', 'BufNewFile' }, {
                              group = 'filetypedetect',
                              command = "if !did_filetype() && expand('<amatch>') !~ g:ft_ignore_pat | runtime! scripts.vim | endif",
                            })
                            
                            vim.api.nvim_create_autocmd('StdinReadPost', {
                              group = 'filetypedetect',
                              command = 'if !did_filetype() | runtime! scripts.vim | endif',
                            })
                            
                            if not vim.g.ft_ignore_pat then
                              vim.g.ft_ignore_pat = '\\.\\(Z\\|gz\\|bz2\\|zip\\|tgz\\)$'
                            end

SCRIPT  /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/syntax/syntax.vim
Sourced 1 time
Total time:   0.000207
 Self time:   0.000127

count  total (s)   self (s)
                            " Vim syntax support file
                            " Maintainer:	The Vim Project <https://github.com/vim/vim>
                            " Last Change:	2023 Aug 10
                            " Former Maintainer:	Bram Moolenaar <Bram@vim.org>
                            
                            " This file is used for ":syntax on".
                            " It installs the autocommands and starts highlighting for all buffers.
                            
    1              0.000002 if !has("syntax")
                              finish
    1              0.000000 endif
                            
                            " If Syntax highlighting appears to be on already, turn it off first, so that
                            " any leftovers are cleared.
    1              0.000001 if exists("syntax_on") || exists("syntax_manual")
                              so <sfile>:p:h/nosyntax.vim
    1              0.000000 endif
                            
                            " Load the Syntax autocommands and set the default methods for highlighting.
    1   0.000158   0.000103 runtime syntax/synload.vim
                            
                            " Load the FileType autocommands if not done yet.
    1              0.000001 if exists("did_load_filetypes")
    1              0.000001   let s:did_ft = 1
                            else
                              filetype on
                              let s:did_ft = 0
    1              0.000000 endif
                            
                            " Set up the connection between FileType and Syntax autocommands.
                            " This makes the syntax automatically set when the file type is detected
                            " unless treesitter highlighting is enabled.
                            " Avoid an error when 'verbose' is set and <amatch> expansion fails.
    1              0.000002 augroup syntaxset
    1              0.000002   au! FileType *	if !exists('b:ts_highlight') | 0verbose exe "set syntax=" . expand("<amatch>") | endif
    1              0.000000 augroup END
                            
                            " Execute the syntax autocommands for the each buffer.
                            " If the filetype wasn't detected yet, do that now.
                            " Always do the syntaxset autocommands, for buffers where the 'filetype'
                            " already was set manually (e.g., help buffers).
    1   0.000028   0.000002 doautoall syntaxset FileType
    1              0.000001 if !s:did_ft
                              doautoall filetypedetect BufRead
    1              0.000001 endif

SCRIPT  /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/syntax/synload.vim
Sourced 1 time
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
                            " Vim syntax support file
                            " Maintainer:	The Vim Project <https://github.com/vim/vim>
                            " Last Change:	2023 Aug 10
                            " Former Maintainer:	Bram Moolenaar <Bram@vim.org>
                            
                            " This file sets up for syntax highlighting.
                            " It is loaded from "syntax.vim" and "manual.vim".
                            " 1. Set the default highlight groups.
                            " 2. Install Syntax autocommands for all the available syntax files.
                            
    1              0.000001 if !has("syntax")
                              finish
    1              0.000000 endif
                            
                            " let others know that syntax has been switched on
    1              0.000001 let syntax_on = 1
                            
                            " Line continuation is used here, remove 'C' from 'cpoptions'
    1              0.000001 let s:cpo_save = &cpo
    1              0.000001 set cpo&vim
                            
                            " First remove all old syntax autocommands.
    1              0.000001 au! Syntax
                            
    1              0.000002 au Syntax *		call s:SynSet()
                            
    1              0.000001 fun! s:SynSet()
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
                              syn clear
                              if exists("b:current_syntax")
                                unlet b:current_syntax
                              endif
                            
                              0verbose let s = expand("<amatch>")
                              if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
                              elseif s == "OFF"
                                let s = ""
                              endif
                            
                              if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.  Skip empty entries.
                                for name in split(s, '\.')
                                  if !empty(name)
                                    " XXX: "[.]" in the first pattern makes it a wildcard on Windows
                                    exe $'runtime! syntax/{name}[.]{{vim,lua}} syntax/{name}/*.{{vim,lua}}'
                                  endif
                                endfor
                              endif
                            endfun
                            
                            
                            " Handle adding doxygen to other languages (C, C++, C#, IDL, java, php, DataScript)
    1              0.000006 au Syntax c,cpp,cs,idl,java,php,datascript
                            	\ if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)
                            	\	|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)
                            	\   | runtime! syntax/doxygen.vim
                            	\ | endif
                            
                            
                            " Source the user-specified syntax highlighting file
    1              0.000001 if exists("mysyntaxfile")
                              let s:fname = expand(mysyntaxfile)
                              if filereadable(s:fname)
                                execute "source " . fnameescape(s:fname)
                              endif
    1              0.000000 endif
                            
                            " Restore 'cpoptions'
    1              0.000001 let &cpo = s:cpo_save
    1              0.000004 unlet s:cpo_save

SCRIPT  /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/autoload/provider/clipboard.vim
Sourced 1 time
Total time:   0.000112
 Self time:   0.000092

count  total (s)   self (s)
                            " The clipboard provider uses shell commands to communicate with the clipboard.
                            " The provider function will only be registered if a supported command is
                            " available.
                            
    1              0.000002 if exists('g:loaded_clipboard_provider')
                              finish
    1              0.000000 endif
                            " Default to 1.  provider#clipboard#Executable() may set 2.
                            " To force a reload:
                            "   :unlet g:loaded_clipboard_provider
                            "   :runtime autoload/provider/clipboard.vim
    1              0.000002 let g:loaded_clipboard_provider = 1
                            
    1              0.000001 let s:copy = {}
    1              0.000001 let s:paste = {}
    1              0.000001 let s:clipboard = {}
                            
                            " When caching is enabled, store the jobid of the xclip/xsel process keeping
                            " ownership of the selection, so we know how long the cache is valid.
    1              0.000002 let s:selection = { 'owner': 0, 'data': [], 'stderr_buffered': v:true }
                            
    1              0.000002 function! s:selection.on_exit(jobid, data, event) abort
                              " At this point this nvim instance might already have launched
                              " a new provider instance. Don't drop ownership in this case.
                              if self.owner == a:jobid
                                let self.owner = 0
                              endif
                              " Don't print if exit code is >= 128 ( exit is 128+SIGNUM if by signal (e.g. 143 on SIGTERM))
                              if a:data > 0 && a:data < 128
                                echohl WarningMsg
                                echomsg 'clipboard: error invoking '.get(self.argv, 0, '?').': '.join(self.stderr)
                                echohl None
                              endif
                            endfunction
                            
    1              0.000003 let s:selections = { '*': s:selection, '+': copy(s:selection) }
                            
    1              0.000001 function! s:try_cmd(cmd, ...) abort
                              let out = systemlist(a:cmd, (a:0 ? a:1 : ['']), 1)
                              if v:shell_error
                                if !exists('s:did_error_try_cmd')
                                  echohl WarningMsg
                                  echomsg "clipboard: error: ".(len(out) ? out[0] : v:shell_error)
                                  echohl None
                                  let s:did_error_try_cmd = 1
                                endif
                                return 0
                              endif
                              return out
                            endfunction
                            
                            " Returns TRUE if `cmd` exits with success, else FALSE.
    1              0.000001 function! s:cmd_ok(cmd) abort
                              call system(a:cmd)
                              return v:shell_error == 0
                            endfunction
                            
    1              0.000001 function! s:split_cmd(cmd) abort
                              return (type(a:cmd) == v:t_string) ? split(a:cmd, " ") : a:cmd
                            endfunction
                            
    1              0.000001 let s:cache_enabled = 1
    1              0.000000 let s:err = ''
                            
    1              0.000001 function! provider#clipboard#Error() abort
                              return s:err
                            endfunction
                            
    1              0.000001 function! provider#clipboard#Executable() abort
                              " Setting g:clipboard to v:false explicitly opts-in to using the "builtin" clipboard providers below
                              if exists('g:clipboard') && g:clipboard isnot# v:false
                                if type({}) isnot# type(g:clipboard)
                                      \ || type({}) isnot# type(get(g:clipboard, 'copy', v:null))
                                      \ || type({}) isnot# type(get(g:clipboard, 'paste', v:null))
                                  let s:err = 'clipboard: invalid g:clipboard'
                                  return ''
                                endif
                            
                                let s:copy = {}
                                let s:copy['+'] = s:split_cmd(get(g:clipboard.copy, '+', v:null))
                                let s:copy['*'] = s:split_cmd(get(g:clipboard.copy, '*', v:null))
                            
                                let s:paste = {}
                                let s:paste['+'] = s:split_cmd(get(g:clipboard.paste, '+', v:null))
                                let s:paste['*'] = s:split_cmd(get(g:clipboard.paste, '*', v:null))
                            
                                let s:cache_enabled = get(g:clipboard, 'cache_enabled', 0)
                                return get(g:clipboard, 'name', 'g:clipboard')
                              elseif has('mac')
                                let s:copy['+'] = ['pbcopy']
                                let s:paste['+'] = ['pbpaste']
                                let s:copy['*'] = s:copy['+']
                                let s:paste['*'] = s:paste['+']
                                let s:cache_enabled = 0
                                return 'pbcopy'
                              elseif !empty($WAYLAND_DISPLAY) && executable('wl-copy') && executable('wl-paste')
                                let s:copy['+'] = ['wl-copy', '--type', 'text/plain']
                                let s:paste['+'] = ['wl-paste', '--no-newline']
                                let s:copy['*'] = ['wl-copy', '--primary', '--type', 'text/plain']
                                let s:paste['*'] = ['wl-paste', '--no-newline', '--primary']
                                return 'wl-copy'
                              elseif !empty($WAYLAND_DISPLAY) && executable('waycopy') && executable('waypaste')
                                let s:copy['+'] = ['waycopy', '-t', 'text/plain']
                                let s:paste['+'] = ['waypaste', '-t', 'text/plain']
                                let s:copy['*'] = s:copy['+']
                                let s:paste['*'] = s:paste['+']
                                return 'wayclip'
                              elseif !empty($DISPLAY) && executable('xsel') && s:cmd_ok('xsel -o -b')
                                let s:copy['+'] = ['xsel', '--nodetach', '-i', '-b']
                                let s:paste['+'] = ['xsel', '-o', '-b']
                                let s:copy['*'] = ['xsel', '--nodetach', '-i', '-p']
                                let s:paste['*'] = ['xsel', '-o', '-p']
                                return 'xsel'
                              elseif !empty($DISPLAY) && executable('xclip')
                                let s:copy['+'] = ['xclip', '-quiet', '-i', '-selection', 'clipboard']
                                let s:paste['+'] = ['xclip', '-o', '-selection', 'clipboard']
                                let s:copy['*'] = ['xclip', '-quiet', '-i', '-selection', 'primary']
                                let s:paste['*'] = ['xclip', '-o', '-selection', 'primary']
                                return 'xclip'
                              elseif executable('lemonade')
                                let s:copy['+'] = ['lemonade', 'copy']
                                let s:paste['+'] = ['lemonade', 'paste']
                                let s:copy['*'] = ['lemonade', 'copy']
                                let s:paste['*'] = ['lemonade', 'paste']
                                return 'lemonade'
                              elseif executable('doitclient')
                                let s:copy['+'] = ['doitclient', 'wclip']
                                let s:paste['+'] = ['doitclient', 'wclip', '-r']
                                let s:copy['*'] = s:copy['+']
                                let s:paste['*'] = s:paste['+']
                                return 'doitclient'
                              elseif executable('win32yank.exe')
                                if has('wsl') && getftype(exepath('win32yank.exe')) == 'link'
                                  let win32yank = resolve(exepath('win32yank.exe'))
                                else
                                  let win32yank = 'win32yank.exe'
                                endif
                                let s:copy['+'] = [win32yank, '-i', '--crlf']
                                let s:paste['+'] = [win32yank, '-o', '--lf']
                                let s:copy['*'] = s:copy['+']
                                let s:paste['*'] = s:paste['+']
                                return 'win32yank'
                              elseif executable('termux-clipboard-set')
                                let s:copy['+'] = ['termux-clipboard-set']
                                let s:paste['+'] = ['termux-clipboard-get']
                                let s:copy['*'] = s:copy['+']
                                let s:paste['*'] = s:paste['+']
                                return 'termux-clipboard'
                              elseif !empty($TMUX) && executable('tmux')
                                let tmux_v = v:lua.vim.version.parse(system(['tmux', '-V']))
                                if !empty(tmux_v) && !v:lua.vim.version.lt(tmux_v, [3,2,0])
                                  let s:copy['+'] = ['tmux', 'load-buffer', '-w', '-']
                                else
                                  let s:copy['+'] = ['tmux', 'load-buffer', '-']
                                endif
                                let s:paste['+'] = ['tmux', 'save-buffer', '-']
                                let s:copy['*'] = s:copy['+']
                                let s:paste['*'] = s:paste['+']
                                return 'tmux'
                              endif
                            
                              let s:err = 'clipboard: No clipboard tool. :help clipboard'
                              return ''
                            endfunction
                            
    1              0.000001 function! s:clipboard.get(reg) abort
                              if type(s:paste[a:reg]) == v:t_func
                                return s:paste[a:reg]()
                              elseif s:selections[a:reg].owner > 0
                                return s:selections[a:reg].data
                              end
                            
                              let clipboard_data = s:try_cmd(s:paste[a:reg])
                              if match(&clipboard, '\v(unnamed|unnamedplus)') >= 0
                                    \ && type(clipboard_data) == v:t_list
                                    \ && get(s:selections[a:reg].data, 0, []) ==# clipboard_data
                                " When system clipboard return is same as our cache return the cache
                                " as it contains regtype information
                                return s:selections[a:reg].data
                              end
                              return clipboard_data
                            endfunction
                            
    1              0.000001 function! s:clipboard.set(lines, regtype, reg) abort
                              if a:reg == '"'
                                call s:clipboard.set(a:lines,a:regtype,'+')
                                if s:copy['*'] != s:copy['+']
                                  call s:clipboard.set(a:lines,a:regtype,'*')
                                end
                                return 0
                              end
                            
                              if type(s:copy[a:reg]) == v:t_func
                                call s:copy[a:reg](a:lines, a:regtype)
                                return 0
                              end
                            
                              if s:cache_enabled == 0
                                call s:try_cmd(s:copy[a:reg], a:lines)
                                "Cache it anyway we can compare it later to get regtype of the yank
                                let s:selections[a:reg] = copy(s:selection)
                                let s:selections[a:reg].data = [a:lines, a:regtype]
                                return 0
                              end
                            
                              if s:selections[a:reg].owner > 0
                                let prev_job = s:selections[a:reg].owner
                              end
                              let s:selections[a:reg] = copy(s:selection)
                              let selection = s:selections[a:reg]
                              let selection.data = [a:lines, a:regtype]
                              let selection.argv = s:copy[a:reg]
                              let selection.detach = s:cache_enabled
                              let selection.cwd = "/"
                              let jobid = jobstart(selection.argv, selection)
                              if jobid > 0
                                call jobsend(jobid, a:lines)
                                call jobclose(jobid, 'stdin')
                                " xclip does not close stdout when receiving input via stdin
                                if selection.argv[0] ==# 'xclip'
                                  call jobclose(jobid, 'stdout')
                                endif
                                let selection.owner = jobid
                                let ret = 1
                              else
                                echohl WarningMsg
                                echomsg 'clipboard: failed to execute: '.(s:copy[a:reg])
                                echohl None
                                let ret = 1
                              endif
                            
                              " The previous provider instance should exit when the new one takes
                              " ownership, but kill it to be sure we don't fill up the job table.
                              if exists('prev_job')
                                call timer_start(1000, {... ->
                                      \ jobwait([prev_job], 0)[0] == -1
                                      \ && jobstop(prev_job)})
                              endif
                            
                              return ret
                            endfunction
                            
    1              0.000001 function! provider#clipboard#Call(method, args) abort
                              if get(s:, 'here', v:false)  " Clipboard provider must not recurse. #7184
                                return 0
                              endif
                              let s:here = v:true
                              try
                                return call(s:clipboard[a:method],a:args,s:clipboard)
                              finally
                                let s:here = v:false
                              endtry
                            endfunction
                            
                            " eval_has_provider() decides based on this variable.
    1   0.000026   0.000006 let g:loaded_clipboard_provider = empty(provider#clipboard#Executable()) ? 1 : 2

SCRIPT  /Users/brunosilveira/.local/share/nvim/lazy/which-key.nvim/plugin/which-key.lua
Sourced 1 time
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
                            local timer = (vim.uv or vim.loop).new_timer()
                            timer:start(
                              500,
                              0,
                              vim.schedule_wrap(function()
                                local wk = require("which-key")
                                if not wk.did_setup then
                                  wk.setup()
                                end
                              end)
                            )

SCRIPT  /Users/brunosilveira/.local/share/nvim/lazy/dressing.nvim/plugin/dressing.lua
Sourced 1 time
Total time:   0.000481
 Self time:   0.000481

count  total (s)   self (s)
                            require("dressing").patch()
                            vim.api.nvim_set_hl(0, "DressingSelectIdx", {
                              link = "Special",
                            })

SCRIPT  /Users/brunosilveira/.local/share/nvim/lazy/nvim-ts-context-commentstring/plugin/ts_context_commentstring.lua
Sourced 1 time
Total time:   0.018225
 Self time:   0.018225

count  total (s)   self (s)
                            if vim.g.loaded_ts_context_commentstring and vim.g.loaded_ts_context_commentstring ~= 0 then
                              return
                            end
                            
                            vim.g.loaded_ts_context_commentstring = 1
                            
                            local group = vim.api.nvim_create_augroup('ts_context_commentstring', { clear = true })
                            vim.api.nvim_create_autocmd('FileType', {
                              group = group,
                              desc = 'Set up nvim-ts-context-commentstring for each buffer that has Treesitter active',
                              callback = function(args)
                                require('ts_context_commentstring.internal').setup_buffer(args.buf)
                              end,
                            })
                            
                            if not vim.g.skip_ts_context_commentstring_module or vim.g.skip_ts_context_commentstring_module == 0 then
                              local nvim_ts_ok, nvim_ts = pcall(require, 'nvim-treesitter')
                              if nvim_ts_ok then
                                if not nvim_ts.define_modules then
                                  -- Running nvim-treesitter >= 1.0, modules are no longer a thing
                                  return
                                end
                            
                                nvim_ts.define_modules {
                                  context_commentstring = {
                                    module_path = 'ts_context_commentstring.internal',
                                  },
                                }
                              end
                            end

SCRIPT  /Users/brunosilveira/.local/share/nvim/lazy/nvim-ts-autotag/plugin/nvim-ts-autotag.lua
Sourced 1 time
Total time:   0.009133
 Self time:   0.009133

count  total (s)   self (s)
                            require("nvim-ts-autotag").init()

SCRIPT  /Users/brunosilveira/.local/share/nvim/lazy/nvim-treesitter/plugin/nvim-treesitter.lua
Sourced 1 time
Total time:   0.000441
 Self time:   0.000441

count  total (s)   self (s)
                            -- Last Change: 2022 Apr 16
                            
                            if vim.g.loaded_nvim_treesitter then
                              return
                            end
                            vim.g.loaded_nvim_treesitter = true
                            
                            -- setup modules
                            require("nvim-treesitter").setup()
                            
                            local api = vim.api
                            
                            -- define autocommands
                            local augroup = api.nvim_create_augroup("NvimTreesitter", {})
                            
                            api.nvim_create_autocmd("Filetype", {
                              pattern = "query",
                              group = augroup,
                              callback = function()
                                api.nvim_clear_autocmds {
                                  group = augroup,
                                  event = "BufWritePost",
                                }
                                api.nvim_create_autocmd("BufWritePost", {
                                  group = augroup,
                                  buffer = 0,
                                  callback = function(opts)
                                    require("nvim-treesitter.query").invalidate_query_file(opts.file)
                                  end,
                                  desc = "Invalidate query file",
                                })
                              end,
                              desc = "Reload query",
                            })

SCRIPT  /Users/brunosilveira/.local/share/nvim/lazy/Comment.nvim/plugin/Comment.lua
Sourced 1 time
Total time:   0.001800
 Self time:   0.001800

count  total (s)   self (s)
                            local K = vim.keymap.set
                            local call = require('Comment.api').call
                            
                            ---@mod comment.keybindings Keybindings
                            ---@brief [[
                            ---Comment.nvim provides default keybindings for (un)comment your code. These
                            ---keybinds are enabled upon calling |comment.usage.setup| and can be configured
                            ---or disabled, if desired.
                            ---
                            ---Basic: ~
                            ---
                            ---  *gc*
                            ---  *gb*
                            ---  *gc[count]{motion}*
                            ---  *gb[count]{motion}*
                            ---
                            ---      Toggle comment on a region using linewise/blockwise comment. In 'NORMAL'
                            ---      mode, it uses 'Operator-Pending' mode to listen for an operator/motion.
                            ---      In 'VISUAL' mode it simply comment the selected region.
                            ---
                            ---  *gcc*
                            ---  *gbc*
                            ---  *[count]gcc*
                            ---  *[count]gbc*
                            ---
                            ---      Toggle comment on the current line using linewise/blockwise comment. If
                            ---      prefixed with a 'v:count' then it will comment over the number of lines
                            ---      corresponding to the {count}. These are only available in 'NORMAL' mode.
                            ---
                            ---
                            ---Extra: ~
                            ---
                            ---  *gco* - Inserts comment below and enters INSERT mode
                            ---  *gcO* - Inserts comment above and enters INSERT mode
                            ---  *gcA* - Inserts comment at the end of line and enters INSERT mode
                            ---@brief ]]
                            
                            ---@mod comment.plugmap Plug Mappings
                            ---@brief [[
                            ---Comment.nvim provides <Plug> mappings for most commonly used actions. These
                            ---are enabled by default and can be used to make custom keybindings. All plug
                            ---mappings have support for dot-repeat except VISUAL mode keybindings. To create
                            ---custom comment function, check out 'comment.api' section.
                            ---
                            ---  *<Plug>(comment_toggle_linewise)*
                            ---  *<Plug>(comment_toggle_blockwise)*
                            ---
                            ---     Toggle comment on a region with linewise/blockwise comment in NORMAL mode.
                            ---     using |Operator-Pending| mode (or |g@|) to get the region to comment.
                            ---     These powers the |gc| and |gb| keybindings.
                            ---
                            ---  *<Plug>(comment_toggle_linewise_current)*
                            ---  *<Plug>(comment_toggle_blockwise_current)*
                            ---
                            ---     Toggle comment on the current line with linewise/blockwise comment in
                            ---     NORMAL mode. These powers the |gcc| and 'gbc' keybindings.
                            ---
                            ---  *<Plug>(comment_toggle_linewise_count)*
                            ---  *<Plug>(comment_toggle_blockwise_count)*
                            ---
                            ---     Toggle comment on a region using 'v:count' with linewise/blockwise comment
                            ---     in NORMAL mode. These powers the |[count]gcc| and |[count]gbc| keybindings.
                            ---
                            ---  *<Plug>(comment_toggle_linewise_visual)*
                            ---  *<Plug>(comment_toggle_blockwise_visual)*
                            ---
                            ---     Toggle comment on the selected region with linewise/blockwise comment in
                            ---     NORMAL mode. These powers the |{visual}gc| and |{visual}gb| keybindings.
                            ---
                            ---Usage: ~
                            --->lua
                            ---    -- Toggle current line or with count
                            ---    vim.keymap.set('n', 'gcc', function()
                            ---        return vim.v.count == 0
                            ---            and '<Plug>(comment_toggle_linewise_current)'
                            ---            or '<Plug>(comment_toggle_linewise_count)'
                            ---    end, { expr = true })
                            ---
                            ---    -- Toggle in Op-pending mode
                            ---    vim.keymap.set('n', 'gc', '<Plug>(comment_toggle_linewise)')
                            ---
                            ---    -- Toggle in VISUAL mode
                            ---    vim.keymap.set('x', 'gc', '<Plug>(comment_toggle_linewise_visual)')
                            ---<
                            ---@brief ]]
                            ---@export plugs
                            
                            -- Operator-Pending mappings
                            K(
                                'n',
                                '<Plug>(comment_toggle_linewise)',
                                call('toggle.linewise', 'g@'),
                                { expr = true, desc = 'Comment toggle linewise' }
                            )
                            K(
                                'n',
                                '<Plug>(comment_toggle_blockwise)',
                                call('toggle.blockwise', 'g@'),
                                { expr = true, desc = 'Comment toggle blockwise' }
                            )
                            
                            -- Toggle mappings
                            K(
                                'n',
                                '<Plug>(comment_toggle_linewise_current)',
                                call('toggle.linewise.current', 'g@$'),
                                { expr = true, desc = 'Comment toggle current line' }
                            )
                            K(
                                'n',
                                '<Plug>(comment_toggle_blockwise_current)',
                                call('toggle.blockwise.current', 'g@$'),
                                { expr = true, desc = 'Comment toggle current block' }
                            )
                            
                            -- Count mappings
                            K(
                                'n',
                                '<Plug>(comment_toggle_linewise_count)',
                                call('toggle.linewise.count_repeat', 'g@$'),
                                { expr = true, desc = 'Comment toggle linewise with count' }
                            )
                            K(
                                'n',
                                '<Plug>(comment_toggle_blockwise_count)',
                                call('toggle.blockwise.count_repeat', 'g@$'),
                                { expr = true, desc = 'Comment toggle blockwise with count' }
                            )
                            
                            -- Visual-Mode mappings
                            K(
                                'x',
                                '<Plug>(comment_toggle_linewise_visual)',
                                '<ESC><CMD>lua require("Comment.api").locked("toggle.linewise")(vim.fn.visualmode())<CR>',
                                { desc = 'Comment toggle linewise (visual)' }
                            )
                            K(
                                'x',
                                '<Plug>(comment_toggle_blockwise_visual)',
                                '<ESC><CMD>lua require("Comment.api").locked("toggle.blockwise")(vim.fn.visualmode())<CR>',
                                { desc = 'Comment toggle blockwise (visual)' }
                            )

SCRIPT  /Users/brunosilveira/.local/share/nvim/lazy/todo-comments.nvim/plugin/todo.vim
Sourced 1 time
Total time:   0.000238
 Self time:   0.000238

count  total (s)   self (s)
    1              0.000007 command! -nargs=* TodoQuickFix lua require("todo-comments.search").setqflist(<q-args>)
    1              0.000004 command! -nargs=* TodoLocList lua require("todo-comments.search").setloclist(<q-args>)
    1              0.000003 command! -nargs=* TodoTelescope Telescope todo-comments todo <args>
    1              0.000003 command! -nargs=* TodoFzfLua lua require("todo-comments.fzf").todo() <args>
    1              0.000004 command! -nargs=* TodoTrouble Trouble todo <args>

SCRIPT  /Users/brunosilveira/.local/share/nvim/lazy/vim-rails/plugin/rails.vim
Sourced 1 time
Total time:   0.000692
 Self time:   0.000692

count  total (s)   self (s)
                            " rails.vim - Detect a rails application
                            " Author:       Tim Pope <http://tpo.pe/>
                            " GetLatestVimScripts: 1567 1 :AutoInstall: rails.vim
                            
                            " Install this file as plugin/rails.vim.
                            
    1              0.000009 if exists('g:loaded_rails') || &cp || v:version < 800
                              finish
    1              0.000001 endif
    1              0.000003 let g:loaded_rails = 1
                            
                            " Turn on $LOAD_PATH detection in the ruby ftplugin
    1              0.000002 if !exists('g:ruby_exec')
    1              0.000001   let g:ruby_exec = 1
    1              0.000001 endif
                            
                            " Utility Functions {{{1
                            
    1              0.000003 function! s:error(str)
                              echohl ErrorMsg
                              echomsg a:str
                              echohl None
                              let v:errmsg = a:str
                            endfunction
                            
    1              0.000002 let s:slash = exists('+shellslash') ? '\' : '/'
    1              0.000001 function! s:IsAbs(path) abort
                              return tr(a:path, s:slash, '/') =~# '^/\|^\a\+:'
                            endfunction
                            
                            " }}}1
                            " Detection {{{1
                            
    1              0.000001 function! RailsDetect(...) abort
                              if exists('b:rails_root')
                                return 1
                              endif
                              if a:0
                                let path = a:1
                              elseif &l:buftype =~# '^\%(nowrite\)\=$' && len(@%) || &l:buftype =~# '^\%(nofile\|acwrite\)' && s:IsAbs(@%)
                                let path = @%
                              else
                                return
                              endif
                              if !s:IsAbs(path)
                                let s = exists('+shellslash') && !&shellslash ? '\' : '/'
                                let path = substitute(getcwd(), '\' . s . '\=$', s, '') . path
                              endif
                              let path = substitute(path, '[' . s:slash . '/]$', '', '')
                              try
                                if exists('*ExcludeBufferFromDiscovery') && ExcludeBufferFromDiscovery(file, 'projectionist')
                                  return
                                endif
                              catch
                              endtry
                            
                              if exists('*ProjectionistHas')
                                let previous = ''
                                while path !=# previous && path !~# '^\.\=$\|^[\/][\/][^\/]*$'
                                  if ProjectionistHas('config/environment.rb&app/', path)
                                    let b:rails_root = path
                                    return 1
                                  endif
                                  let previous = path
                                  let path = fnamemodify(path, ':h')
                                endwhile
                                return 0
                              endif
                              let file = findfile('config/environment.rb', escape(path, ', ').';')
                              if !empty(file) && isdirectory(fnamemodify(file, ':p:h:h') . '/app')
                                let b:rails_root = fnamemodify(file, ':p:h:h')
                                return 1
                              endif
                            endfunction
                            
    1              0.000001 function! s:LogDetect() abort
                              let path = matchstr(get(w:, 'quickfix_title'), '\<cgetfile \zs.*\ze[\\/]log[\\/].*.log$')
                              if !empty(path) && filereadable(path . '/config/environment.rb') && isdirectory(path . '/app')
                                let b:rails_root = path
                                setlocal filetype=railslog
                              endif
                            endfunction
                            
                            " }}}1
                            " Initialization {{{1
                            
    1              0.000002 if !exists('g:did_load_ftplugin')
                              filetype plugin on
    1              0.000000 endif
    1              0.000001 if !exists('g:loaded_projectionist')
    1              0.000408   runtime! plugin/projectionist.vim
    1              0.000001 endif
                            
    1              0.000001 augroup railsPluginDetect
    1              0.000003   autocmd!
                            
    1              0.000004   autocmd BufNewFile,BufReadPost *
                                    \ if RailsDetect() && empty(&filetype) |
                                    \   call rails#buffer_setup() |
                                    \ endif
    1              0.000004   autocmd VimEnter *
                                    \ if get(g:, 'rails_vim_enter', get(g:, 'projectionist_vim_enter', 1)) &&
                                    \     argc() == 0 && RailsDetect(getcwd()) |
                                    \   call rails#buffer_setup() |
                                    \ endif
    1              0.000003   autocmd FileType netrw
                                    \ if RailsDetect(get(b:, 'netrw_curdir', @%)) |
                                    \ endif
    1              0.000002   autocmd FileType * if RailsDetect() | call rails#buffer_setup() | endif
                            
    1              0.000014   autocmd BufNewFile,BufReadPost */config/*.yml{,.example,.sample},*/{test,spec}/fixtures/*.yml
                                    \ if &filetype !=# 'eruby.yaml' && RailsDetect() |
                                    \   set filetype=eruby.yaml |
                                    \ endif
    1              0.000010   autocmd BufNewFile,BufReadPost *.rjs,*.rxml,*.builder,*.jbuilder,*.ruby
                                    \ if &filetype !=# 'ruby' | set filetype=ruby | endif
    1              0.000008   autocmd BufNewFile,BufReadPost *.turbo_stream.erb
                                    \ if &filetype !=# 'eruby.html' | set filetype=eruby.html | endif
    1              0.000002   autocmd BufReadPost *.log if RailsDetect() | set filetype=railslog | endif
                            
    1              0.000002   autocmd FileType qf call s:LogDetect()
                            
    1              0.000004   autocmd User ProjectionistDetect
                                    \ if RailsDetect(get(g:, 'projectionist_file', '')) |
                                    \   call projectionist#append(b:rails_root,
                                    \     {'*': {"console": rails#app().static_rails_command('console')}}) |
                                    \ endif
    1              0.000000 augroup END
                            
    1              0.000008 command! -bang -bar -nargs=* -range=-1 -complete=customlist,rails#complete_rails Rails execute rails#command(<bang>0, '<mods>', <count>, <q-args>)
                            
                            " }}}1
                            " dadbod.vim support {{{1
                            
    1              0.000008 call extend(g:, {'db_adapters': {}}, 'keep')
    1              0.000008 call extend(g:db_adapters, {
                                  \ 'oracle-enhanced': 'oracle',
                                  \ 'mysql2': 'mysql',
                                  \ 'sqlite3': 'sqlite'}, 'keep')
                            
    1              0.000001 let g:db_adapter_rails = 'rails#db_'
                            
                            " }}}1
                            " abolish.vim support {{{1
                            
    1              0.000001 augroup railsPluginAbolish
    1              0.000003   autocmd!
    1              0.000002   autocmd VimEnter * call s:abolish_setup()
    1              0.000000 augroup END
                            
    1              0.000001 function! s:abolish_setup()
                              if exists('g:Abolish') && has_key(g:Abolish,'Coercions')
                                if !has_key(g:Abolish.Coercions,'l')
                                  let g:Abolish.Coercions.l = function('s:abolish_l')
                                endif
                                if !has_key(g:Abolish.Coercions,'t') || string(g:Abolish.Coercions.t) =~# "'<SNR>[0-9]*_titlecase'"
                                  let g:Abolish.Coercions.t = function('s:abolish_t')
                                endif
                              endif
                            endfunction
                            
    1              0.000001 function! s:abolish_l(word)
                              let singular = rails#singularize(a:word)
                              return a:word ==? singular ? rails#pluralize(a:word) : singular
                            endfunction
                            
    1              0.000001 function! s:abolish_t(word)
                              if a:word =~# '\u'
                                return rails#pluralize(rails#underscore(a:word))
                              else
                                return rails#singularize(rails#camelize(a:word))
                              endif
                            endfunction
                            
                            " }}}1
                            " vim:set sw=2 sts=2:

SCRIPT  /Users/brunosilveira/.local/share/nvim/lazy/indent-blankline.nvim/after/plugin/commands.lua
Sourced 1 time
Total time:   0.003651
 Self time:   0.003651

count  total (s)   self (s)
                            local ibl = require "ibl"
                            local conf = require "ibl.config"
                            
                            vim.api.nvim_create_user_command("IBLEnable", function()
                                ibl.update { enabled = true }
                            end, {
                                bar = true,
                                desc = "Enables indent-blankline",
                            })
                            
                            vim.api.nvim_create_user_command("IBLDisable", function()
                                ibl.update { enabled = false }
                            end, {
                                bar = true,
                                desc = "Disables indent-blankline",
                            })
                            
                            vim.api.nvim_create_user_command("IBLToggle", function()
                                if ibl.initialized then
                                    ibl.update { enabled = not conf.get_config(-1).enabled }
                                else
                                    ibl.setup {}
                                end
                            end, {
                                bar = true,
                                desc = "Toggles indent-blankline on and off",
                            })
                            
                            vim.api.nvim_create_user_command("IBLEnableScope", function()
                                ibl.update { scope = { enabled = true } }
                            end, {
                                bar = true,
                                desc = "Enables indent-blanklines scope",
                            })
                            
                            vim.api.nvim_create_user_command("IBLDisableScope", function()
                                ibl.update { scope = { enabled = false } }
                            end, {
                                bar = true,
                                desc = "Disables indent-blanklines scope",
                            })
                            
                            vim.api.nvim_create_user_command("IBLToggleScope", function()
                                if ibl.initialized then
                                    ibl.update { scope = { enabled = not conf.get_config(-1).scope.enabled } }
                                else
                                    ibl.setup {}
                                end
                            end, {
                                bar = true,
                                desc = "Toggles indent-blanklines scope on and off",
                            })

SCRIPT  /Users/brunosilveira/.local/share/nvim/lazy/conform.nvim/plugin/conform.lua
Sourced 1 time
Total time:   0.000496
 Self time:   0.000496

count  total (s)   self (s)
                            vim.api.nvim_create_user_command("ConformInfo", function()
                              require("conform.health").show_window()
                            end, { desc = "Show information about Conform formatters" })

SCRIPT  /Users/brunosilveira/.local/share/nvim/lazy/cmp-buffer/after/plugin/cmp_buffer.lua
Sourced 1 time
Total time:   0.008504
 Self time:   0.008504

count  total (s)   self (s)
                            require('cmp').register_source('buffer', require('cmp_buffer'))

SCRIPT  /Users/brunosilveira/.local/share/nvim/lazy/cmp-path/after/plugin/cmp_path.lua
Sourced 1 time
Total time:   0.000551
 Self time:   0.000551

count  total (s)   self (s)
                            require('cmp').register_source('path', require('cmp_path').new())

SCRIPT  /Users/brunosilveira/.local/share/nvim/lazy/LuaSnip/plugin/luasnip.lua
Sourced 1 time
Total time:   0.005162
 Self time:   0.005162

count  total (s)   self (s)
                            vim.filetype.add({
                            	extension = { snippets = "snippets" },
                            })
                            
                            local function silent_map(mode, lhs, rhs, desc)
                            	vim.keymap.set(mode, lhs, rhs, { silent = true, desc = desc or "" })
                            end
                            
                            silent_map("i", "<Plug>luasnip-expand-or-jump", function()
                            	require("luasnip").expand_or_jump()
                            end, "LuaSnip: Expand or jump in the current snippet")
                            silent_map("i", "<Plug>luasnip-expand-snippet", function()
                            	require("luasnip").expand()
                            end, "LuaSnip: Expand the current snippet")
                            silent_map("i", "<Plug>luasnip-next-choice", function()
                            	require("luasnip").change_choice(1)
                            end, "LuaSnip: Change to the next choice from the choiceNode")
                            silent_map("i", "<Plug>luasnip-prev-choice", function()
                            	require("luasnip").change_choice(-1)
                            end, "LuaSnip: Change to the previous choice from the choiceNode")
                            silent_map("i", "<Plug>luasnip-jump-next", function()
                            	require("luasnip").jump(1)
                            end, "LuaSnip: Jump to the next node")
                            silent_map("i", "<Plug>luasnip-jump-prev", function()
                            	require("luasnip").jump(-1)
                            end, "LuaSnip: Jump to the previous node")
                            
                            silent_map("n", "<Plug>luasnip-delete-check", function()
                            	require("luasnip").unlink_current_if_deleted()
                            end, "LuaSnip: Removes current snippet from jumplist")
                            silent_map("!", "<Plug>luasnip-delete-check", function()
                            	require("luasnip").unlink_current_if_deleted()
                            end, "LuaSnip: Removes current snippet from jumplist")
                            
                            silent_map("", "<Plug>luasnip-expand-repeat", function()
                            	require("luasnip").expand_repeat()
                            end, "LuaSnip: Repeat last node expansion")
                            silent_map("!", "<Plug>luasnip-expand-repeat", function()
                            	require("luasnip").expand_repeat()
                            end, "LuaSnip: Repeat last node expansion")
                            
                            silent_map("s", "<Plug>luasnip-expand-or-jump", function()
                            	require("luasnip").expand_or_jump()
                            end, "LuaSnip: Expand or jump in the current snippet")
                            silent_map("s", "<Plug>luasnip-expand-snippet", function()
                            	require("luasnip").expand()
                            end, "LuaSnip: Expand the current snippet")
                            silent_map("s", "<Plug>luasnip-next-choice", function()
                            	require("luasnip").change_choice(1)
                            end, "LuaSnip: Change to the next choice from the choiceNode")
                            silent_map("s", "<Plug>luasnip-prev-choice", function()
                            	require("luasnip").change_choice(-1)
                            end, "LuaSnip: Change to the previous choice from the choiceNode")
                            silent_map("s", "<Plug>luasnip-jump-next", function()
                            	require("luasnip").jump(1)
                            end, "LuaSnip: Jump to the next node")
                            silent_map("s", "<Plug>luasnip-jump-prev", function()
                            	require("luasnip").jump(-1)
                            end, "LuaSnip: Jump to the previous node")
                            
                            vim.api.nvim_create_user_command("LuaSnipUnlinkCurrent", function()
                            	require("luasnip").unlink_current()
                            end, { force = true })
                            
                            --stylua: ignore
                            vim.api.nvim_create_user_command("LuaSnipListAvailable", function()
                            	(
                            		(
                            			vim.version
                            			and type(vim.version) == "table"
                            			and (
                            				((vim.version().major == 0) and (vim.version().minor >= 9))
                            				or (vim.version().major > 0) )
                            		) and vim.print
                            		  or vim.pretty_print
                            	)(require("luasnip").available())
                            end, { force = true })
                            
                            require("luasnip.config")._setup()
                            
                            -- register these during startup so lazy_load will also load filetypes whose
                            -- events fired only before lazy_load is actually called.
                            -- (BufWinEnter -> lazy_load() wouldn't load any files without these).
                            vim.api.nvim_create_augroup("_luasnip_lazy_load", {})
                            vim.api.nvim_create_autocmd({ "BufWinEnter", "FileType" }, {
                            	callback = function(event)
                            		require("luasnip.loaders").load_lazy_loaded(tonumber(event.buf))
                            	end,
                            	group = "_luasnip_lazy_load",
                            })

SCRIPT  /Users/brunosilveira/.local/share/nvim/lazy/LuaSnip/plugin/luasnip.vim
Sourced 1 time
Total time:   0.000056
 Self time:   0.000056

count  total (s)   self (s)
    1              0.000003 function! luasnip#expandable()
                            	return luaeval('require("luasnip").expandable()')
                            endfunction
                            
    1              0.000001 function! luasnip#expand_or_jumpable()
                            	return luaeval('require("luasnip").expand_or_jumpable()')
                            endfunction
                            
    1              0.000001 function! luasnip#expand_or_locally_jumpable()
                            	return luaeval('require("luasnip").expand_or_locally_jumpable()')
                            endfunction
                            
    1              0.000001 function! luasnip#locally_jumpable(direction)
                            	return luaeval('require("luasnip").locally_jumpable(_A)', a:direction)
                            endfunction
                            
    1              0.000001 function! luasnip#jumpable(direction)
                            	return luaeval('require("luasnip").jumpable(_A)', a:direction)
                            endfunction
                            
    1              0.000001 function! luasnip#choice_active()
                            	return luaeval('require("luasnip").choice_active()')
                            endfunction

SCRIPT  /Users/brunosilveira/.local/share/nvim/lazy/cmp_luasnip/after/plugin/cmp_luasnip.lua
Sourced 1 time
Total time:   0.000684
 Self time:   0.000684

count  total (s)   self (s)
                            require("cmp").register_source("luasnip", require("cmp_luasnip").new())
                            
                            local cmp_luasnip = vim.api.nvim_create_augroup("cmp_luasnip", {})
                            
                            vim.api.nvim_create_autocmd("User", {
                              pattern = "LuasnipCleanup",
                              callback = function ()
                                require("cmp_luasnip").clear_cache()
                              end,
                              group = cmp_luasnip
                            })
                            
                            vim.api.nvim_create_autocmd("User", {
                              pattern = "LuasnipSnippetsAdded",
                              callback = function ()
                                require("cmp_luasnip").refresh()
                              end,
                              group = cmp_luasnip
                            })

SCRIPT  /Users/brunosilveira/.local/share/nvim/lazy/nvim-cmp/plugin/cmp.lua
Sourced 1 time
Total time:   0.000346
 Self time:   0.000346

count  total (s)   self (s)
                            if vim.g.loaded_cmp then
                              return
                            end
                            vim.g.loaded_cmp = true
                            
                            if not vim.api.nvim_create_autocmd then
                              return print('[nvim-cmp] Your nvim does not has `nvim_create_autocmd` function. Please update to latest nvim.')
                            end
                            
                            local api = require('cmp.utils.api')
                            local types = require('cmp.types')
                            local highlight = require('cmp.utils.highlight')
                            local autocmd = require('cmp.utils.autocmd')
                            
                            vim.api.nvim_set_hl(0, 'CmpItemAbbr', { link = 'CmpItemAbbrDefault', default = true })
                            vim.api.nvim_set_hl(0, 'CmpItemAbbrDeprecated', { link = 'CmpItemAbbrDeprecatedDefault', default = true })
                            vim.api.nvim_set_hl(0, 'CmpItemAbbrMatch', { link = 'CmpItemAbbrMatchDefault', default = true })
                            vim.api.nvim_set_hl(0, 'CmpItemAbbrMatchFuzzy', { link = 'CmpItemAbbrMatchFuzzyDefault', default = true })
                            vim.api.nvim_set_hl(0, 'CmpItemKind', { link = 'CmpItemKindDefault', default = true })
                            vim.api.nvim_set_hl(0, 'CmpItemMenu', { link = 'CmpItemMenuDefault', default = true })
                            for kind in pairs(types.lsp.CompletionItemKind) do
                              if type(kind) == 'string' then
                                local name = ('CmpItemKind%s'):format(kind)
                                vim.api.nvim_set_hl(0, name, { link = ('%sDefault'):format(name), default = true })
                              end
                            end
                            
                            autocmd.subscribe({ 'ColorScheme', 'UIEnter' }, function()
                              highlight.inherit('CmpItemAbbrDefault', 'Pmenu', { bg = 'NONE', default = false })
                              highlight.inherit('CmpItemAbbrDeprecatedDefault', 'Comment', { bg = 'NONE', default = false })
                              highlight.inherit('CmpItemAbbrMatchDefault', 'Pmenu', { bg = 'NONE', default = false })
                              highlight.inherit('CmpItemAbbrMatchFuzzyDefault', 'Pmenu', { bg = 'NONE', default = false })
                              highlight.inherit('CmpItemKindDefault', 'Special', { bg = 'NONE', default = false })
                              highlight.inherit('CmpItemMenuDefault', 'Pmenu', { bg = 'NONE', default = false })
                              for name in pairs(types.lsp.CompletionItemKind) do
                                if type(name) == 'string' then
                                  vim.api.nvim_set_hl(0, ('CmpItemKind%sDefault'):format(name), { link = 'CmpItemKind', default = false })
                                end
                              end
                            end)
                            autocmd.emit('ColorScheme')
                            
                            if vim.on_key then
                              local control_c_termcode = vim.api.nvim_replace_termcodes('<C-c>', true, true, true)
                              vim.on_key(function(keys)
                                if keys == control_c_termcode then
                                  vim.schedule(function()
                                    if not api.is_suitable_mode() then
                                      autocmd.emit('InsertLeave')
                                    end
                                  end)
                                end
                              end, vim.api.nvim_create_namespace('cmp.plugin'))
                            end
                            
                            
                            vim.api.nvim_create_user_command('CmpStatus', function()
                              require('cmp').status()
                            end, { desc = 'Check status of cmp sources' })
                            
                            vim.cmd([[doautocmd <nomodeline> User CmpReady]])

SCRIPT  /Users/brunosilveira/.local/share/nvim/lazy/copilot.vim/plugin/copilot.vim
Sourced 1 time
Total time:   0.000329
 Self time:   0.000298

count  total (s)   self (s)
    1              0.000004 if exists('g:loaded_copilot')
                              finish
    1              0.000000 endif
    1              0.000002 let g:loaded_copilot = 1
                            
    1              0.000001 scriptencoding utf-8
                            
    1              0.000011 command! -bang -nargs=? -range=-1 -complete=customlist,copilot#CommandComplete Copilot exe copilot#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)
                            
    1              0.000002 if v:version < 800 || !exists('##InsertLeavePre')
                              finish
    1              0.000000 endif
                            
    1              0.000001 function! s:ColorScheme() abort
                              if &t_Co == 256
                                hi def CopilotSuggestion guifg=#808080 ctermfg=244
                              else
                                hi def CopilotSuggestion guifg=#808080 ctermfg=12
                              endif
                              hi def link CopilotAnnotation MoreMsg
                            endfunction
                            
    1              0.000001 function! s:MapTab() abort
                              if get(g:, 'copilot_no_tab_map') || get(g:, 'copilot_no_maps')
                                return
                              endif
                              let tab_map = maparg('<Tab>', 'i', 0, 1)
                              if !has_key(tab_map, 'rhs')
                                imap <script><silent><nowait><expr> <Tab> empty(get(g:, 'copilot_no_tab_map')) ? copilot#Accept() : "\t"
                              elseif tab_map.rhs !~# 'copilot'
                                if tab_map.expr
                                  let tab_fallback = '{ -> ' . tab_map.rhs . ' }'
                                else
                                  let tab_fallback = substitute(json_encode(tab_map.rhs), '<', '\\<', 'g')
                                endif
                                let tab_fallback = substitute(tab_fallback, '<SID>', '<SNR>' . get(tab_map, 'sid') . '_', 'g')
                                if get(tab_map, 'noremap') || get(tab_map, 'script') || mapcheck('<Left>', 'i') || mapcheck('<Del>', 'i')
                                  exe 'imap <script><silent><nowait><expr> <Tab> copilot#Accept(' . tab_fallback . ')'
                                else
                                  exe 'imap <silent><nowait><expr>         <Tab> copilot#Accept(' . tab_fallback . ')'
                                endif
                              endif
                            endfunction
                            
    1              0.000001 function! s:Event(type) abort
                              try
                                call call('copilot#On' . a:type, [])
                              catch
                                call copilot#logger#Exception('autocmd.' . a:type)
                              endtry
                            endfunction
                            
    1              0.000001 augroup github_copilot
    1              0.000005   autocmd!
    1              0.000002   autocmd FileType             * call s:Event('FileType')
    1              0.000001   autocmd InsertLeavePre       * call s:Event('InsertLeavePre')
    1              0.000001   autocmd BufLeave             * if mode() =~# '^[iR]'|call s:Event('InsertLeavePre')|endif
    1              0.000001   autocmd InsertEnter          * call s:Event('InsertEnter')
    1              0.000001   autocmd BufEnter             * if mode() =~# '^[iR]'|call s:Event('InsertEnter')|endif
    1              0.000001   autocmd BufEnter             * call s:Event('BufEnter')
    1              0.000001   autocmd CursorMovedI         * call s:Event('CursorMovedI')
    1              0.000001   autocmd CompleteChanged      * call s:Event('CompleteChanged')
    1              0.000002   autocmd ColorScheme,VimEnter * call s:ColorScheme()
    1              0.000001   autocmd VimEnter             * call s:MapTab() | call copilot#Init()
    1              0.000001   autocmd BufUnload            * call s:Event('BufUnload')
    1              0.000002   autocmd VimLeavePre          * call s:Event('VimLeavePre')
    1              0.000002   autocmd BufReadCmd copilot://* setlocal buftype=nofile bufhidden=wipe nobuflisted nomodifiable
    1              0.000002   autocmd BufReadCmd copilot:///log call copilot#logger#BufReadCmd() | setfiletype copilotlog
    1              0.000000 augroup END
                            
    1   0.000012   0.000004 call s:ColorScheme()
    1   0.000026   0.000003 call s:MapTab()
    1              0.000001 if !get(g:, 'copilot_no_maps')
    1              0.000003   imap <Plug>(copilot-dismiss)     <Cmd>call copilot#Dismiss()<CR>
    1              0.000005   if empty(mapcheck('<C-]>', 'i'))
    1              0.000002     imap <silent><script><nowait><expr> <C-]> copilot#Dismiss() . "\<C-]>"
    1              0.000000   endif
    1              0.000002   imap <Plug>(copilot-next)     <Cmd>call copilot#Next()<CR>
    1              0.000002   imap <Plug>(copilot-previous) <Cmd>call copilot#Previous()<CR>
    1              0.000006   imap <Plug>(copilot-suggest)  <Cmd>call copilot#Suggest()<CR>
    1              0.000002   imap <script><silent><nowait><expr> <Plug>(copilot-accept-word) copilot#AcceptWord()
    1              0.000002   imap <script><silent><nowait><expr> <Plug>(copilot-accept-line) copilot#AcceptLine()
    1              0.000001   try
    1              0.000002     if !has('nvim') && &encoding ==# 'utf-8'
                                  " avoid 8-bit meta collision with UTF-8 characters
                                  let s:restore_encoding = 1
                                  silent noautocmd set encoding=cp949
    1              0.000000     endif
    1              0.000002     if empty(mapcheck('<M-]>', 'i'))
    1              0.000001       imap <M-]> <Plug>(copilot-next)
    1              0.000000     endif
    1              0.000002     if empty(mapcheck('<M-[>', 'i'))
    1              0.000001       imap <M-[> <Plug>(copilot-previous)
    1              0.000000     endif
    1              0.000002     if empty(mapcheck('<M-Bslash>', 'i'))
    1              0.000002       imap <M-Bslash> <Plug>(copilot-suggest)
    1              0.000000     endif
    1              0.000002     if empty(mapcheck('<M-Right>', 'i'))
    1              0.000001       imap <M-Right> <Plug>(copilot-accept-word)
    1              0.000000     endif
    1              0.000002     if empty(mapcheck('<M-C-Right>', 'i'))
    1              0.000001       imap <M-C-Right> <Plug>(copilot-accept-line)
    1              0.000000     endif
    1              0.000001   finally
    1              0.000001     if exists('s:restore_encoding')
                                  silent noautocmd set encoding=utf-8
    1              0.000000     endif
    1              0.000001   endtry
    1              0.000000 endif
                            
    1              0.000002 let s:dir = expand('<sfile>:h:h')
    1              0.000007 if getftime(s:dir . '/doc/copilot.txt') > getftime(s:dir . '/doc/tags')
                              silent! execute 'helptags' fnameescape(s:dir . '/doc')
    1              0.000001 endif

SCRIPT  /Users/brunosilveira/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim
Sourced 1 time
Total time:   0.000994
 Self time:   0.000994

count  total (s)   self (s)
    1              0.000002 scriptencoding utf-8
                            
    1              0.000004 let s:has_nvim_ghost_text = has('nvim-0.7') && exists('*nvim_buf_get_mark')
    1              0.000001 let s:vim_minimum_version = '9.0.0185'
    1              0.000002 let s:has_vim_ghost_text = has('patch-' . s:vim_minimum_version) && has('textprop')
    1              0.000001 let s:has_ghost_text = s:has_nvim_ghost_text || s:has_vim_ghost_text
                            
    1              0.000001 let s:hlgroup = 'CopilotSuggestion'
    1              0.000001 let s:annot_hlgroup = 'CopilotAnnotation'
                            
    1              0.000001 if s:has_vim_ghost_text && empty(prop_type_get(s:hlgroup))
                              call prop_type_add(s:hlgroup, {'highlight': s:hlgroup})
    1              0.000000 endif
    1              0.000001 if s:has_vim_ghost_text && empty(prop_type_get(s:annot_hlgroup))
                              call prop_type_add(s:annot_hlgroup, {'highlight': s:annot_hlgroup})
    1              0.000000 endif
                            
    1              0.000001 function! s:Echo(msg) abort
                              if has('nvim') && &cmdheight == 0
                                call v:lua.vim.notify(a:msg, v:null, {'title': 'GitHub Copilot'})
                              else
                                echo a:msg
                              endif
                            endfunction
                            
    1              0.000001 function! s:EditorConfiguration() abort
                              let filetypes = copy(s:filetype_defaults)
                              if type(get(g:, 'copilot_filetypes')) == v:t_dict
                                call extend(filetypes, g:copilot_filetypes)
                              endif
                              return {
                                    \ 'enableAutoCompletions': empty(get(g:, 'copilot_enabled', 1)) ? v:false : v:true,
                                    \ 'disabledLanguages': map(sort(keys(filter(filetypes, { k, v -> empty(v) }))), { _, v -> {'languageId': v}}),
                                    \ }
                            endfunction
                            
    1              0.000001 function! copilot#Init(...) abort
                              call copilot#util#Defer({ -> exists('s:client') || s:Start() })
                            endfunction
                            
    1              0.000000 function! s:Running() abort
                              return exists('s:client.job') || exists('s:client.client_id')
                            endfunction
                            
    1              0.000000 function! s:Start() abort
                              if s:Running() || exists('s:client.startup_error')
                                return
                              endif
                              let s:client = copilot#client#New({'editorConfiguration' : s:EditorConfiguration()})
                            endfunction
                            
    1              0.000000 function! s:Stop() abort
                              if exists('s:client')
                                let client = remove(s:, 'client')
                                call client.Close()
                              endif
                            endfunction
                            
    1              0.000001 function! copilot#Client() abort
                              call s:Start()
                              return s:client
                            endfunction
                            
    1              0.000001 function! copilot#RunningClient() abort
                              if s:Running()
                                return s:client
                              else
                                return v:null
                              endif
                            endfunction
                            
    1              0.000476 if has('nvim-0.7') && !has(luaeval('vim.version().api_prerelease') ? 'nvim-0.8.1' : 'nvim-0.8.0')
                              let s:editor_warning = 'Neovim 0.7 support is deprecated and will be dropped in a future release of copilot.vim.'
    1              0.000000 endif
    1              0.000002 if has('vim_starting') && exists('s:editor_warning')
                              call copilot#logger#Warn(s:editor_warning)
    1              0.000000 endif
    1              0.000001 function! s:EditorVersionWarning() abort
                              if exists('s:editor_warning')
                                echohl WarningMsg
                                echo 'Warning: ' . s:editor_warning
                                echohl None
                              endif
                            endfunction
                            
    1              0.000001 function! copilot#Request(method, params, ...) abort
                              let client = copilot#Client()
                              return call(client.Request, [a:method, a:params] + a:000)
                            endfunction
                            
    1              0.000001 function! copilot#Call(method, params, ...) abort
                              let client = copilot#Client()
                              return call(client.Call, [a:method, a:params] + a:000)
                            endfunction
                            
    1              0.000000 function! copilot#Notify(method, params, ...) abort
                              let client = copilot#Client()
                              return call(client.Notify, [a:method, a:params] + a:000)
                            endfunction
                            
    1              0.000000 function! copilot#NvimNs() abort
                              return nvim_create_namespace('github-copilot')
                            endfunction
                            
    1              0.000000 function! copilot#Clear() abort
                              if exists('g:_copilot_timer')
                                call timer_stop(remove(g:, '_copilot_timer'))
                              endif
                              if exists('b:_copilot')
                                call copilot#client#Cancel(get(b:_copilot, 'first', {}))
                                call copilot#client#Cancel(get(b:_copilot, 'cycling', {}))
                              endif
                              call s:UpdatePreview()
                              unlet! b:_copilot
                              return ''
                            endfunction
                            
    1              0.000000 function! copilot#Dismiss() abort
                              call copilot#Clear()
                              call s:UpdatePreview()
                              return ''
                            endfunction
                            
    1              0.000003 let s:filetype_defaults = {
                                  \ 'gitcommit': 0,
                                  \ 'gitrebase': 0,
                                  \ 'hgcommit': 0,
                                  \ 'svn': 0,
                                  \ 'cvs': 0,
                                  \ '.': 0}
                            
    1              0.000001 function! s:BufferDisabled() abort
                              if &buftype =~# '^\%(help\|prompt\|quickfix\|terminal\)$'
                                return 5
                              endif
                              if exists('b:copilot_disabled')
                                return empty(b:copilot_disabled) ? 0 : 3
                              endif
                              if exists('b:copilot_enabled')
                                return empty(b:copilot_enabled) ? 4 : 0
                              endif
                              let short = empty(&l:filetype) ? '.' : split(&l:filetype, '\.', 1)[0]
                              let config = {}
                              if type(get(g:, 'copilot_filetypes')) == v:t_dict
                                let config = g:copilot_filetypes
                              endif
                              if has_key(config, &l:filetype)
                                return empty(config[&l:filetype])
                              elseif has_key(config, short)
                                return empty(config[short])
                              elseif has_key(config, '*')
                                return empty(config['*'])
                              else
                                return get(s:filetype_defaults, short, 1) == 0 ? 2 : 0
                              endif
                            endfunction
                            
    1              0.000000 function! copilot#Enabled() abort
                              return get(g:, 'copilot_enabled', 1)
                                    \ && empty(s:BufferDisabled())
                            endfunction
                            
    1              0.000001 let s:inline_invoked = 1
    1              0.000001 let s:inline_automatic = 2
                            
    1              0.000000 function! copilot#Complete(...) abort
                              if exists('g:_copilot_timer')
                                call timer_stop(remove(g:, '_copilot_timer'))
                              endif
                              let target = [bufnr(''), getbufvar('', 'changedtick'), line('.'), col('.')]
                              if !exists('b:_copilot.target') || b:_copilot.target !=# target
                                if exists('b:_copilot.first')
                                  call copilot#client#Cancel(b:_copilot.first)
                                endif
                                if exists('b:_copilot.cycling')
                                  call copilot#client#Cancel(b:_copilot.cycling)
                                endif
                                let params = {
                                      \ 'textDocument': {'uri': bufnr('')},
                                      \ 'position': copilot#util#AppendPosition(),
                                      \ 'formattingOptions': {'insertSpaces': &expandtab ? v:true : v:false, 'tabSize': shiftwidth()},
                                      \ 'context': {'triggerKind': s:inline_automatic}}
                                let b:_copilot = {
                                      \ 'target': target,
                                      \ 'params': params,
                                      \ 'first': copilot#Request('textDocument/inlineCompletion', params)}
                                let g:_copilot_last = b:_copilot
                              endif
                              let completion = b:_copilot.first
                              if !a:0
                                return completion.Await()
                              else
                                call copilot#client#Result(completion, function(a:1, [b:_copilot]))
                                if a:0 > 1
                                  call copilot#client#Error(completion, function(a:2, [b:_copilot]))
                                endif
                              endif
                            endfunction
                            
    1              0.000001 function! s:HideDuringCompletion() abort
                              return get(g:, 'copilot_hide_during_completion', 1)
                            endfunction
                            
    1              0.000001 function! s:SuggestionTextWithAdjustments() abort
                              let empty = ['', 0, 0, {}]
                              try
                                if mode() !~# '^[iR]' || (s:HideDuringCompletion() && pumvisible()) || !exists('b:_copilot.suggestions')
                                  return empty
                                endif
                                let choice = get(b:_copilot.suggestions, b:_copilot.choice, {})
                                if !has_key(choice, 'range') || choice.range.start.line != line('.') - 1 || type(choice.insertText) !=# v:t_string
                                  return empty
                                endif
                                let line = getline('.')
                                let offset = col('.') - 1
                                let choice_text = strpart(line, 0, copilot#util#UTF16ToByteIdx(line, choice.range.start.character)) . substitute(choice.insertText, "\n*$", '', '')
                                let typed = strpart(line, 0, offset)
                                let end_offset = copilot#util#UTF16ToByteIdx(line, choice.range.end.character)
                                if end_offset < 0
                                  let end_offset = len(line)
                                endif
                                let delete = strpart(line, offset, end_offset - offset)
                                if typed =~# '^\s*$'
                                  let leading = matchstr(choice_text, '^\s\+')
                                  let unindented = strpart(choice_text, len(leading))
                                  if strpart(typed, 0, len(leading)) == leading && unindented !=# delete
                                    return [unindented, len(typed) - len(leading), strchars(delete), choice]
                                  endif
                                elseif typed ==# strpart(choice_text, 0, offset)
                                  return [strpart(choice_text, offset), 0, strchars(delete), choice]
                                endif
                              catch
                                call copilot#logger#Exception()
                              endtry
                              return empty
                            endfunction
                            
                            
    1              0.000001 function! s:Advance(count, context, ...) abort
                              if a:context isnot# get(b:, '_copilot', {})
                                return
                              endif
                              let a:context.choice += a:count
                              if a:context.choice < 0
                                let a:context.choice += len(a:context.suggestions)
                              endif
                              let a:context.choice %= len(a:context.suggestions)
                              call s:UpdatePreview()
                            endfunction
                            
    1              0.000001 function! s:GetSuggestionsCyclingCallback(context, result) abort
                              let callbacks = remove(a:context, 'cycling_callbacks')
                              let seen = {}
                              for suggestion in a:context.suggestions
                                let seen[suggestion.insertText] = 1
                              endfor
                              for suggestion in get(a:result, 'items', [])
                                if !has_key(seen, suggestion.insertText)
                                  call add(a:context.suggestions, suggestion)
                                  let seen[suggestion.insertText] = 1
                                endif
                              endfor
                              for Callback in callbacks
                                call Callback(a:context)
                              endfor
                            endfunction
                            
    1              0.000001 function! s:GetSuggestionsCycling(callback) abort
                              if exists('b:_copilot.cycling_callbacks')
                                call add(b:_copilot.cycling_callbacks, a:callback)
                              elseif exists('b:_copilot.cycling')
                                call a:callback(b:_copilot)
                              elseif exists('b:_copilot.suggestions')
                                let params = deepcopy(b:_copilot.first.params)
                                let params.context.triggerKind = s:inline_invoked
                                let b:_copilot.cycling_callbacks = [a:callback]
                                let b:_copilot.cycling = copilot#Request('textDocument/inlineCompletion',
                                      \ params,
                                      \ function('s:GetSuggestionsCyclingCallback', [b:_copilot]),
                                      \ function('s:GetSuggestionsCyclingCallback', [b:_copilot]),
                                      \ )
                                call s:UpdatePreview()
                              endif
                              return ''
                            endfunction
                            
    1              0.000000 function! copilot#Next() abort
                              return s:GetSuggestionsCycling(function('s:Advance', [1]))
                            endfunction
                            
    1              0.000000 function! copilot#Previous() abort
                              return s:GetSuggestionsCycling(function('s:Advance', [-1]))
                            endfunction
                            
    1              0.000001 function! copilot#GetDisplayedSuggestion() abort
                              let [text, outdent, delete, item] = s:SuggestionTextWithAdjustments()
                            
                              return {
                                    \ 'item': item,
                                    \ 'text': text,
                                    \ 'outdentSize': outdent,
                                    \ 'deleteSize': delete}
                            endfunction
                            
    1              0.000001 function! s:ClearPreview() abort
                              if s:has_nvim_ghost_text
                                call nvim_buf_del_extmark(0, copilot#NvimNs(), 1)
                              elseif s:has_vim_ghost_text
                                call prop_remove({'type': s:hlgroup, 'all': v:true})
                                call prop_remove({'type': s:annot_hlgroup, 'all': v:true})
                              endif
                            endfunction
                            
    1              0.000000 function! s:UpdatePreview() abort
                              try
                                let [text, outdent, delete, item] = s:SuggestionTextWithAdjustments()
                                let text = split(text, "\r\n\\=\\|\n", 1)
                                if empty(text[-1])
                                  call remove(text, -1)
                                endif
                                if empty(text) || !s:has_ghost_text
                                  return s:ClearPreview()
                                endif
                                if exists('b:_copilot.cycling_callbacks')
                                  let annot = '(1/)'
                                elseif exists('b:_copilot.cycling')
                                  let annot = '(' . (b:_copilot.choice + 1) . '/' . len(b:_copilot.suggestions) . ')'
                                else
                                  let annot = ''
                                endif
                                call s:ClearPreview()
                                if s:has_nvim_ghost_text
                                  let data = {'id': 1}
                                  let data.virt_text_pos = 'overlay'
                                  let append = strpart(getline('.'), col('.') - 1 + delete)
                                  let data.virt_text = [[text[0] . append . repeat(' ', delete - len(text[0])), s:hlgroup]]
                                  if len(text) > 1
                                    let data.virt_lines = map(text[1:-1], { _, l -> [[l, s:hlgroup]] })
                                    if !empty(annot)
                                      let data.virt_lines[-1] += [[' '], [annot, s:annot_hlgroup]]
                                    endif
                                  elseif len(annot)
                                    let data.virt_text += [[' '], [annot, s:annot_hlgroup]]
                                  endif
                                  let data.hl_mode = 'combine'
                                  call nvim_buf_set_extmark(0, copilot#NvimNs(), line('.')-1, col('.')-1, data)
                                elseif s:has_vim_ghost_text
                                  let new_suffix = text[0]
                                  let current_suffix = getline('.')[col('.') - 1 :]
                                  let inset = ''
                                  while delete > 0 && !empty(new_suffix)
                                    let last_char = matchstr(new_suffix, '.$')
                                    let new_suffix = matchstr(new_suffix, '^.\{-\}\ze.$')
                                    if last_char ==# matchstr(current_suffix, '.$')
                                      if !empty(inset)
                                        call prop_add(line('.'), col('.') + len(current_suffix), {'type': s:hlgroup, 'text': inset})
                                        let inset = ''
                                      endif
                                      let current_suffix = matchstr(current_suffix, '^.\{-\}\ze.$')
                                      let delete -= 1
                                    else
                                      let inset = last_char . inset
                                    endif
                                  endwhile
                                  if !empty(new_suffix . inset)
                                    call prop_add(line('.'), col('.'), {'type': s:hlgroup, 'text': new_suffix . inset})
                                  endif
                                  for line in text[1:]
                                    call prop_add(line('.'), 0, {'type': s:hlgroup, 'text_align': 'below', 'text': line})
                                  endfor
                                  if !empty(annot)
                                    call prop_add(line('.'), col('$'), {'type': s:annot_hlgroup, 'text': ' ' . annot})
                                  endif
                                endif
                                call copilot#Notify('textDocument/didShowCompletion', {'item': item})
                              catch
                                return copilot#logger#Exception()
                              endtry
                            endfunction
                            
    1              0.000002 function! s:HandleTriggerResult(state, result) abort
                              let a:state.suggestions = type(a:result) == type([]) ? a:result : get(empty(a:result) ? {} : a:result, 'items', [])
                              let a:state.choice = 0
                              if get(b:, '_copilot') is# a:state
                                call s:UpdatePreview()
                              endif
                            endfunction
                            
    1              0.000001 function! s:HandleTriggerError(state, result) abort
                              let a:state.suggestions = []
                              let a:state.choice = 0
                              let a:state.error = a:result
                              if get(b:, '_copilot') is# a:state
                                call s:UpdatePreview()
                              endif
                            endfunction
                            
    1              0.000000 function! copilot#Suggest() abort
                              if !s:Running()
                                return ''
                              endif
                              try
                                call copilot#Complete(function('s:HandleTriggerResult'), function('s:HandleTriggerError'))
                              catch
                                call copilot#logger#Exception()
                              endtry
                              return ''
                            endfunction
                            
    1              0.000001 function! s:Trigger(bufnr, timer) abort
                              let timer = get(g:, '_copilot_timer', -1)
                              if a:bufnr !=# bufnr('') || a:timer isnot# timer || mode() !=# 'i'
                                return
                              endif
                              unlet! g:_copilot_timer
                              return copilot#Suggest()
                            endfunction
                            
    1              0.000000 function! copilot#Schedule() abort
                              if !s:has_ghost_text || !s:Running() || !copilot#Enabled()
                                call copilot#Clear()
                                return
                              endif
                              call s:UpdatePreview()
                              let delay = get(g:, 'copilot_idle_delay', 45)
                              call timer_stop(get(g:, '_copilot_timer', -1))
                              let g:_copilot_timer = timer_start(delay, function('s:Trigger', [bufnr('')]))
                            endfunction
                            
    1              0.000000 function! s:Attach(bufnr, ...) abort
                              try
                                return copilot#Client().Attach(a:bufnr)
                              catch
                                call copilot#logger#Exception()
                              endtry
                            endfunction
                            
    1              0.000000 function! copilot#OnFileType() abort
                              if empty(s:BufferDisabled()) && &l:modifiable && &l:buflisted
                                call copilot#util#Defer(function('s:Attach'), bufnr(''))
                              endif
                            endfunction
                            
    1              0.000000 function! s:Focus(bufnr, ...) abort
                              if s:Running() && copilot#Client().IsAttached(a:bufnr)
                                call copilot#Client().Notify('textDocument/didFocus', {'textDocument': {'uri': copilot#Client().Attach(a:bufnr).uri}})
                              endif
                            endfunction
                            
    1              0.000000 function! copilot#OnBufEnter() abort
                              let bufnr = bufnr('')
                              call copilot#util#Defer(function('s:Focus'), bufnr)
                            endfunction
                            
    1              0.000000 function! copilot#OnInsertLeavePre() abort
                              call copilot#Clear()
                              call s:ClearPreview()
                            endfunction
                            
    1              0.000000 function! copilot#OnInsertEnter() abort
                              return copilot#Schedule()
                            endfunction
                            
    1              0.000000 function! copilot#OnCompleteChanged() abort
                              if s:HideDuringCompletion()
                                return copilot#Clear()
                              else
                                return copilot#Schedule()
                              endif
                            endfunction
                            
    1              0.000000 function! copilot#OnCursorMovedI() abort
                              return copilot#Schedule()
                            endfunction
                            
    1              0.000000 function! copilot#OnBufUnload() abort
                            endfunction
                            
    1              0.000000 function! copilot#OnVimLeavePre() abort
                            endfunction
                            
    1              0.000001 function! copilot#TextQueuedForInsertion() abort
                              try
                                return remove(s:, 'suggestion_text')
                              catch
                                return ''
                              endtry
                            endfunction
                            
    1              0.000000 function! copilot#Accept(...) abort
                              let s = copilot#GetDisplayedSuggestion()
                              if !empty(s.text)
                                unlet! b:_copilot
                                let text = ''
                                if a:0 > 1
                                  let text = substitute(matchstr(s.text, "\n*" . '\%(' . a:2 .'\)'), "\n*$", '', '')
                                endif
                                if empty(text)
                                  let text = s.text
                                endif
                                if text ==# s.text && has_key(s.item, 'command')
                                  call copilot#Request('workspace/executeCommand', s.item.command)
                                else
                                  let line_text = strpart(getline('.'), 0, col('.') - 1) . text
                                  call copilot#Notify('textDocument/didPartiallyAcceptCompletion', {
                                        \ 'item': s.item,
                                        \ 'acceptedLength': copilot#util#UTF16Width(line_text) - s.item.range.start.character})
                                endif
                                call s:ClearPreview()
                                let s:suggestion_text = text
                                let recall = text =~# "\n" ? "\<C-R>\<C-O>=" : "\<C-R>\<C-R>="
                                return repeat("\<Left>\<Del>", s.outdentSize) . repeat("\<Del>", s.deleteSize) .
                                        \ recall . "copilot#TextQueuedForInsertion()\<CR>" . (a:0 > 1 ? '' : "\<End>")
                              endif
                              let default = get(g:, 'copilot_tab_fallback', pumvisible() ? "\<C-N>" : "\t")
                              if !a:0
                                return default
                              elseif type(a:1) == v:t_string
                                return a:1
                              elseif type(a:1) == v:t_func
                                try
                                  return call(a:1, [])
                                catch
                                  return default
                                endtry
                              else
                                return default
                              endif
                            endfunction
                            
    1              0.000000 function! copilot#AcceptWord(...) abort
                              return copilot#Accept(a:0 ? a:1 : '', '\%(\k\@!.\)*\k*')
                            endfunction
                            
    1              0.000001 function! copilot#AcceptLine(...) abort
                              return copilot#Accept(a:0 ? a:1 : "\r", "[^\n]\\+")
                            endfunction
                            
    1              0.000001 function! s:BrowserCallback(into, code) abort
                              let a:into.code = a:code
                            endfunction
                            
    1              0.000000 function! copilot#Browser() abort
                              if type(get(g:, 'copilot_browser')) == v:t_list
                                let cmd = copy(g:copilot_browser)
                              elseif type(get(g:, 'open_command')) == v:t_list
                                let cmd = copy(g:open_command)
                              elseif has('win32')
                                let cmd = ['rundll32', 'url.dll,FileProtocolHandler']
                              elseif has('mac')
                                let cmd = ['open']
                              elseif executable('wslview')
                                return ['wslview']
                              elseif executable('xdg-open')
                                return ['xdg-open']
                              else
                                return []
                              endif
                              if executable(get(cmd, 0, ''))
                                return cmd
                              else
                                return []
                              endif
                            endfunction
                            
    1              0.000001 let s:commands = {}
                            
    1              0.000001 function! s:EnabledStatusMessage() abort
                              let buf_disabled = s:BufferDisabled()
                              if !s:has_ghost_text
                                if has('nvim')
                                  return "Neovim 0.6 required to support ghost text"
                                else
                                  return "Vim " . s:vim_minimum_version . " required to support ghost text"
                                endif
                              elseif !get(g:, 'copilot_enabled', 1)
                                return 'Disabled globally by :Copilot disable'
                              elseif buf_disabled is# 5
                                return 'Disabled for current buffer by buftype=' . &buftype
                              elseif buf_disabled is# 4
                                return 'Disabled for current buffer by b:copilot_enabled'
                              elseif buf_disabled is# 3
                                return 'Disabled for current buffer by b:copilot_disabled'
                              elseif buf_disabled is# 2
                                return 'Disabled for filetype=' . &filetype . ' by internal default'
                              elseif buf_disabled
                                return 'Disabled for filetype=' . &filetype . ' by g:copilot_filetypes'
                              elseif !copilot#Enabled()
                                return 'BUG: Something is wrong with enabling/disabling'
                              else
                                return ''
                              endif
                            endfunction
                            
    1              0.000000 function! s:VerifySetup() abort
                              let error = copilot#Client().StartupError()
                              if !empty(error)
                                echo 'Copilot: ' . error
                                return
                              endif
                            
                              let status = copilot#Call('checkStatus', {})
                            
                              if !has_key(status, 'user')
                                echo 'Copilot: Not authenticated. Invoke :Copilot setup'
                                return
                              endif
                            
                              if status.status ==# 'NoTelemetryConsent'
                                echo 'Copilot: Telemetry terms not accepted. Invoke :Copilot setup'
                                return
                              endif
                            
                              if status.status ==# 'NotAuthorized'
                                echo "Copilot: You don't have access to GitHub Copilot. Sign up by visiting https://github.com/settings/copilot"
                                return
                              endif
                            
                              return 1
                            endfunction
                            
    1              0.000001 function! s:commands.status(opts) abort
                              if !s:VerifySetup()
                                return
                              endif
                            
                              if exists('s:client.status.status') && s:client.status.status =~# 'Warning\|Error'
                                echo 'Copilot: ' . s:client.status.status
                                if !empty(get(s:client.status, 'message', ''))
                                  echon ': ' . s:client.status.message
                                endif
                                return
                              endif
                            
                              let status = s:EnabledStatusMessage()
                              if !empty(status)
                                echo 'Copilot: ' . status
                                return
                              endif
                            
                              echo 'Copilot: Ready'
                              call s:EditorVersionWarning()
                            endfunction
                            
    1              0.000001 function! s:commands.signout(opts) abort
                              let status = copilot#Call('checkStatus', {'options': {'localChecksOnly': v:true}})
                              if has_key(status, 'user')
                                echo 'Copilot: Signed out as GitHub user ' . status.user
                              else
                                echo 'Copilot: Not signed in'
                              endif
                              call copilot#Call('signOut', {})
                            endfunction
                            
    1              0.000000 function! s:commands.setup(opts) abort
                              let startup_error = copilot#Client().StartupError()
                              if !empty(startup_error)
                                  echo 'Copilot: ' . startup_error
                                  return
                              endif
                            
                              let browser = copilot#Browser()
                            
                              let status = copilot#Call('checkStatus', {})
                              if has_key(status, 'user')
                                let data = {'status': 'AlreadySignedIn', 'user': status.user}
                              else
                                let data = copilot#Call('signInInitiate', {})
                              endif
                            
                              if has_key(data, 'verificationUri')
                                let uri = data.verificationUri
                                if has('clipboard')
                                  try
                                    let @+ = data.userCode
                                  catch
                                  endtry
                                  try
                                    let @* = data.userCode
                                  catch
                                  endtry
                                endif
                                let codemsg = "First copy your one-time code: " . data.userCode . "\n"
                                try
                                  if len(&mouse)
                                    let mouse = &mouse
                                    set mouse=
                                  endif
                                  if get(a:opts, 'bang')
                                    call s:Echo(codemsg . "In your browser, visit " . uri)
                                  elseif len(browser)
                                    call input(codemsg . "Press ENTER to open GitHub in your browser\n")
                                    let status = {}
                                    call copilot#job#Stream(browser + [uri], v:null, v:null, function('s:BrowserCallback', [status]))
                                    let time = reltime()
                                    while empty(status) && reltimefloat(reltime(time)) < 5
                                      sleep 10m
                                    endwhile
                                    if get(status, 'code', browser[0] !=# 'xdg-open') != 0
                                      call s:Echo("Failed to open browser.  Visit " . uri)
                                    else
                                      call s:Echo("Opened " . uri)
                                    endif
                                  else
                                    call s:Echo(codemsg . "Could not find browser.  Visit " . uri)
                                  endif
                                  call s:Echo("Waiting (could take up to 10 seconds)")
                                  let request = copilot#Request('signInConfirm', {'userCode': data.userCode}).Wait()
                                finally
                                  if exists('mouse')
                                    let &mouse = mouse
                                  endif
                                endtry
                                if request.status ==# 'error'
                                  return 'echoerr ' . string('Copilot: Authentication failure: ' . request.error.message)
                                else
                                  let status = request.result
                                endif
                              elseif get(data, 'status', '') isnot# 'AlreadySignedIn'
                                return 'echoerr ' . string('Copilot: Something went wrong')
                              endif
                            
                              let user = get(status, 'user', '<unknown>')
                            
                              echo 'Copilot: Authenticated as GitHub user ' . user
                            endfunction
                            
    1              0.000002 let s:commands.auth = s:commands.setup
    1              0.000001 let s:commands.signin = s:commands.setup
                            
    1              0.000000 function! s:commands.help(opts) abort
                              return a:opts.mods . ' help ' . (len(a:opts.arg) ? ':Copilot_' . a:opts.arg : 'copilot')
                            endfunction
                            
    1              0.000000 function! s:commands.version(opts) abort
                              echo 'copilot.vim ' .copilot#client#EditorPluginInfo().version
                              let editorInfo = copilot#client#EditorInfo()
                              echo editorInfo.name . ' ' . editorInfo.version
                              if s:Running()
                                let versions = s:client.Request('getVersion', {})
                                if exists('s:client.serverInfo.version')
                                  echo s:client.serverInfo.name . ' ' . s:client.serverInfo.version
                                else
                                  echo 'GitHub Copilot Language Server ' . versions.Await().version
                                endif
                                if exists('s:client.node_version')
                                  echo 'Node.js ' . s:client.node_version
                                else
                                  echo 'Node.js ' . substitute(get(versions.Await(), 'runtimeVersion', '?'), '^node/', '', 'g')
                                endif
                              else
                                echo 'Not running'
                                if exists('s:client.node_version')
                                  echo 'Node.js ' . s:client.node_version
                                endif
                              endif
                              if has('win32')
                                echo 'Windows'
                              elseif has('macunix')
                                echo 'macOS'
                              elseif !has('unix')
                                echo 'Unknown OS'
                              elseif isdirectory('/sys/kernel')
                                echo 'Linux'
                              else
                                echo 'UNIX'
                              endif
                              call s:EditorVersionWarning()
                            endfunction
                            
    1              0.000001 function! s:UpdateEditorConfiguration() abort
                              try
                                if s:Running()
                                  call copilot#Notify('notifyChangeConfiguration', {'settings': s:EditorConfiguration()})
                                endif
                              catch
                                call copilot#logger#Exception()
                              endtry
                            endfunction
                            
    1              0.000001 let s:feedback_url = 'https://github.com/orgs/community/discussions/categories/copilot'
    1              0.000000 function! s:commands.feedback(opts) abort
                              echo s:feedback_url
                              let browser = copilot#Browser()
                              if len(browser)
                                call copilot#job#Stream(browser + [s:feedback_url], v:null, v:null, v:null)
                              endif
                            endfunction
                            
    1              0.000000 function! s:commands.restart(opts) abort
                              call s:Stop()
                              echo 'Copilot: Restarting language server'
                              call s:Start()
                            endfunction
                            
    1              0.000000 function! s:commands.disable(opts) abort
                              let g:copilot_enabled = 0
                              call s:UpdateEditorConfiguration()
                            endfunction
                            
    1              0.000000 function! s:commands.enable(opts) abort
                              let g:copilot_enabled = 1
                              call s:UpdateEditorConfiguration()
                            endfunction
                            
    1              0.000000 function! s:commands.panel(opts) abort
                              if s:VerifySetup()
                                return copilot#panel#Open(a:opts)
                              endif
                            endfunction
                            
    1              0.000000 function! s:commands.log(opts) abort
                              return a:opts.mods . ' split +$ copilot:///log'
                            endfunction
                            
    1              0.000001 function! copilot#CommandComplete(arg, lead, pos) abort
                              let args = matchstr(strpart(a:lead, 0, a:pos), 'C\%[opilot][! ] *\zs.*')
                              if args !~# ' '
                                return sort(filter(map(keys(s:commands), { k, v -> tr(v, '_', '-') }),
                                      \ { k, v -> strpart(v, 0, len(a:arg)) ==# a:arg }))
                              else
                                return []
                              endif
                            endfunction
                            
    1              0.000001 function! copilot#Command(line1, line2, range, bang, mods, arg) abort
                              let cmd = matchstr(a:arg, '^\%(\\.\|\S\)\+')
                              let arg = matchstr(a:arg, '\s\zs\S.*')
                              if !empty(cmd) && !has_key(s:commands, tr(cmd, '-', '_'))
                                return 'echoerr ' . string('Copilot: unknown command ' . string(cmd))
                              endif
                              try
                                if empty(cmd)
                                  if !s:Running()
                                    let cmd = 'restart'
                                  else
                                    try
                                      let opts = copilot#Call('checkStatus', {'options': {'localChecksOnly': v:true}})
                                      if opts.status !=# 'OK' && opts.status !=# 'MaybeOK'
                                        let cmd = 'setup'
                                      else
                                        let cmd = 'panel'
                                      endif
                                    catch
                                      call copilot#logger#Exception()
                                      let cmd = 'log'
                                    endtry
                                  endif
                                endif
                                let opts = {'line1': a:line1, 'line2': a:line2, 'range': a:range, 'bang': a:bang, 'mods': a:mods, 'arg': arg}
                                let retval = s:commands[tr(cmd, '-', '_')](opts)
                                if type(retval) == v:t_string
                                  return retval
                                else
                                  return ''
                                endif
                              catch /^Copilot:/
                                return 'echoerr ' . string(v:exception)
                              endtry
                            endfunction

SCRIPT  /Users/brunosilveira/.local/share/nvim/lazy/copilot.vim/autoload/copilot/util.vim
Sourced 1 time
Total time:   0.000554
 Self time:   0.000554

count  total (s)   self (s)
    1              0.000010 let s:deferred = []
                            
    1              0.000005 function! copilot#util#Nop(...) abort
                              return v:null
                            endfunction
                            
    1              0.000002 function! copilot#util#Defer(fn, ...) abort
                              call add(s:deferred, function(a:fn, a:000))
                              return timer_start(0, function('s:RunDeferred'))
                            endfunction
                            
    1              0.000003 function! s:RunDeferred(...) abort
                              if empty(s:deferred)
                                return
                              endif
                              let Fn = remove(s:deferred, 0)
                              call timer_start(0, function('s:RunDeferred'))
                              call call(Fn, [])
                            endfunction
                            
    1              0.000002 function! copilot#util#UTF16Width(str) abort
                              return strchars(substitute(a:str, "\\%#=2[^\u0001-\uffff]", "  ", 'g'))
                            endfunction
                            
    1              0.000007 if exists('*utf16idx')
                            
    1              0.000003   function! copilot#util#UTF16ToByteIdx(str, utf16_idx) abort
                                return byteidx(a:str, a:utf16_idx, 1)
                              endfunction
                            
                            elseif has('nvim')
                            
                              function! copilot#util#UTF16ToByteIdx(str, utf16_idx) abort
                                try
                                  return v:lua.vim.str_byteindex(a:str, a:utf16_idx, 1)
                                catch /^Vim(return):E5108:/
                                  return -1
                                endtry
                              endfunction
                            
                            else
                            
                              function! copilot#util#UTF16ToByteIdx(str, utf16_idx) abort
                                if copilot#util#UTF16Width(a:str) < a:utf16_idx
                                  return -1
                                endif
                                let end_offset = len(a:str)
                                while copilot#util#UTF16Width(strpart(a:str, 0, end_offset)) > a:utf16_idx && end_offset > 0
                                  let end_offset -= 1
                                endwhile
                                return end_offset
                              endfunction
                            
    1              0.000001 endif
                            
    1              0.000002 function! copilot#util#AppendPosition() abort
                              let line = getline('.')
                              let col_byte = col('.') - (mode() =~# '^[iR]' || empty(line))
                              let col_utf16 = copilot#util#UTF16Width(strpart(line, 0, col_byte))
                              return {'line': line('.') - 1, 'character': col_utf16}
                            endfunction

SCRIPT  /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/ftplugin/lua.vim
Sourced 2 times
Total time:   0.000692
 Self time:   0.000692

count  total (s)   self (s)
                            " Vim filetype plugin file.
                            " Language:		Lua
                            " Maintainer:		Doug Kearns <dougkearns@gmail.com>
                            " Previous Maintainer:	Max Ischenko <mfi@ukr.net>
                            " Contributor:		Dorai Sitaram <ds26@gte.com>
                            "			C.D. MacEachern <craig.daniel.maceachern@gmail.com>
                            "			Tyler Miller <tmillr@proton.me>
                            " Last Change:		2024 Jan 14
                            
    2              0.000020 if exists("b:did_ftplugin")
                              finish
    2              0.000001 endif
    2              0.000007 let b:did_ftplugin = 1
                            
    2              0.000005 let s:cpo_save = &cpo
    2              0.000015 set cpo&vim
                            
    2              0.000009 setlocal comments=:---,:--
    2              0.000005 setlocal commentstring=--\ %s
    2              0.000008 setlocal formatoptions-=t formatoptions+=croql
                            
    2              0.000008 let &l:define = '\<function\|\<local\%(\s\+function\)\='
                            
                            " TODO: handle init.lua
    2              0.000005 setlocal includeexpr=tr(v:fname,'.','/')
    2              0.000005 setlocal suffixesadd=.lua
                            
    2              0.000003 let b:undo_ftplugin = "setlocal cms< com< def< fo< inex< sua<"
                            
    2              0.000006 if exists("loaded_matchit") && !exists("b:match_words")
    2              0.000003   let b:match_ignorecase = 0
    2              0.000012   let b:match_words =
                            	\ '\<\%(do\|function\|if\)\>:' ..
                            	\ '\<\%(return\|else\|elseif\)\>:' ..
                            	\ '\<end\>,' ..
                            	\ '\<repeat\>:\<until\>,' ..
                            	\ '\%(--\)\=\[\(=*\)\[:]\1]'
    2              0.000006   let b:undo_ftplugin ..= " | unlet! b:match_words b:match_ignorecase"
    2              0.000001 endif
                            
    2              0.000013 if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
                              let b:browsefilter = "Lua Source Files (*.lua)\t*.lua\n"
                              if has("win32")
                                let b:browsefilter ..= "All Files (*.*)\t*\n"
                              else
                                let b:browsefilter ..= "All Files (*)\t*\n"
                              endif
                              let b:undo_ftplugin ..= " | unlet! b:browsefilter"
    2              0.000001 endif
                            
    2              0.000007 let &cpo = s:cpo_save
    2              0.000004 unlet s:cpo_save
                            
                            " vim: nowrap sw=2 sts=2 ts=8 noet:

SCRIPT  /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/ftplugin/lua.lua
Sourced 2 times
Total time:   0.005674
 Self time:   0.005674

count  total (s)   self (s)
                            -- use treesitter over syntax
                            vim.treesitter.start()

SCRIPT  /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/indent/lua.vim
Sourced 2 times
Total time:   0.000522
 Self time:   0.000522

count  total (s)   self (s)
                            " Vim indent file
                            " Language:	Lua script
                            " Maintainer:	Marcus Aurelius Farias <marcus.cf 'at' bol.com.br>
                            " First Author:	Max Ischenko <mfi 'at' ukr.net>
                            " Last Change:	2017 Jun 13
                            "		2022 Sep 07: b:undo_indent added by Doug Kearns
                            
                            " Only load this indent file when no other was loaded.
    2              0.000012 if exists("b:did_indent")
                              finish
    2              0.000001 endif
    2              0.000003 let b:did_indent = 1
                            
    2              0.000012 setlocal indentexpr=GetLuaIndent()
                            
                            " To make Vim call GetLuaIndent() when it finds '\s*end' or '\s*until'
                            " on the current line ('else' is default and includes 'elseif').
    2              0.000005 setlocal indentkeys+=0=end,0=until
                            
    2              0.000003 setlocal autoindent
                            
    2              0.000003 let b:undo_indent = "setlocal autoindent< indentexpr< indentkeys<"
                            
                            " Only define the function once.
    2              0.000004 if exists("*GetLuaIndent")
    1              0.000001   finish
    1              0.000000 endif
                            
    1              0.000001 function! GetLuaIndent()
                                let ignorecase_save = &ignorecase
                              try
                                let &ignorecase = 0
                                return GetLuaIndentIntern()
                              finally
                                let &ignorecase = ignorecase_save
                              endtry
                            endfunction
                            
    1              0.000001 function! GetLuaIndentIntern()
                              " Find a non-blank line above the current line.
                              let prevlnum = prevnonblank(v:lnum - 1)
                            
                              " Hit the start of the file, use zero indent.
                              if prevlnum == 0
                                return 0
                              endif
                            
                              " Add a 'shiftwidth' after lines that start a block:
                              " 'function', 'if', 'for', 'while', 'repeat', 'else', 'elseif', '{'
                              let ind = indent(prevlnum)
                              let prevline = getline(prevlnum)
                              let midx = match(prevline, '^\s*\%(if\>\|for\>\|while\>\|repeat\>\|else\>\|elseif\>\|do\>\|then\>\)')
                              if midx == -1
                                let midx = match(prevline, '{\s*\%(--\%([^[].*\)\?\)\?$')
                                if midx == -1
                                  let midx = match(prevline, '\<function\>\s*\%(\k\|[.:]\)\{-}\s*(')
                                endif
                              endif
                            
                              if midx != -1
                                " Add 'shiftwidth' if what we found previously is not in a comment and
                                " an "end" or "until" is not present on the same line.
                                if synIDattr(synID(prevlnum, midx + 1, 1), "name") != "luaComment" && prevline !~ '\<end\>\|\<until\>'
                                  let ind = ind + shiftwidth()
                                endif
                              endif
                            
                              " Subtract a 'shiftwidth' on end, else, elseif, until and '}'
                              " This is the part that requires 'indentkeys'.
                              let midx = match(getline(v:lnum), '^\s*\%(end\>\|else\>\|elseif\>\|until\>\|}\)')
                              if midx != -1 && synIDattr(synID(v:lnum, midx + 1, 1), "name") != "luaComment"
                                let ind = ind - shiftwidth()
                              endif
                            
                              return ind
                            endfunction

SCRIPT  /Users/brunosilveira/.local/share/nvim/lazy/copilot.vim/autoload/copilot/client.vim
Sourced 1 time
Total time:   0.000906
 Self time:   0.000679

count  total (s)   self (s)
    1              0.000003 scriptencoding utf-8
                            
    1   0.000327   0.000100 let s:plugin_version = copilot#version#String()
                            
    1              0.000002 let s:error_canceled = {'code': -32800, 'message': 'Canceled'}
    1              0.000001 let s:error_exit = {'code': -32097, 'message': 'Process exited'}
    1              0.000002 let s:error_connection_inactive = {'code': -32096, 'message': 'Connection inactive'}
                            
    1              0.000003 let s:root = expand('<sfile>:h:h:h')
                            
    1              0.000001 if !exists('s:instances')
    1              0.000001   let s:instances = {}
    1              0.000000 endif
                            
                            " allow sourcing this file to reload the Lua file too
    1              0.000002 if has('nvim')
    1              0.000006   lua package.loaded._copilot = nil
    1              0.000000 endif
                            
    1              0.000001 function! s:Warn(msg) abort
                              if !empty(get(g:, 'copilot_no_startup_warnings'))
                                return
                              endif
                              echohl WarningMsg
                              echomsg 'Copilot: ' . a:msg
                              echohl NONE
                            endfunction
                            
    1              0.000001 function! s:VimClose() dict abort
                              if !has_key(self, 'job')
                                return
                              endif
                              let job = self.job
                              if has_key(self, 'kill')
                                call job_stop(job, 'kill')
                                call copilot#logger#Warn('Process forcefully terminated')
                                return
                              endif
                              let self.kill = v:true
                              let self.shutdown = self.Request('shutdown', {}, function(self.Notify, ['exit']))
                              call timer_start(2000, { _ -> job_stop(job, 'kill') })
                              call copilot#logger#Debug('Process shutdown initiated')
                            endfunction
                            
    1              0.000001 function! s:LogSend(request, line) abort
                              return '--> ' . a:line
                            endfunction
                            
    1              0.000001 function! s:RejectRequest(request, error) abort
                              if a:request.status !=# 'running'
                                return
                              endif
                              let a:request.waiting = {}
                              call remove(a:request, 'resolve')
                              let reject = remove(a:request, 'reject')
                              let a:request.status = 'error'
                              let a:request.error = deepcopy(a:error)
                              for Cb in reject
                                let a:request.waiting[timer_start(0, function('s:Callback', [a:request, 'error', Cb]))] = 1
                              endfor
                              if index([s:error_canceled.code, s:error_connection_inactive.code], a:error.code) != -1
                                return
                              endif
                              let msg = 'Method ' . a:request.method . ' errored with E' . a:error.code . ': ' . json_encode(a:error.message)
                              if empty(reject)
                                call copilot#logger#Error(msg)
                              else
                                call copilot#logger#Debug(msg)
                              endif
                            endfunction
                            
    1              0.000001 function! s:AfterInitialized(fn, ...) dict abort
                              call add(self.after_initialized, function(a:fn, a:000))
                            endfunction
                            
    1              0.000001 function! s:Send(instance, request) abort
                              if !has_key(a:instance, 'job')
                                return v:false
                              endif
                              try
                                call ch_sendexpr(a:instance.job, a:request)
                                return v:true
                              catch /^Vim\%((\a\+)\)\=:E906:/
                                let a:instance.kill = v:true
                                let job = remove(a:instance, 'job')
                                call job_stop(job)
                                call timer_start(2000, { _ -> job_stop(job, 'kill') })
                                call copilot#logger#Warn('Terminating process after failed write')
                                return v:false
                              catch /^Vim\%((\a\+)\)\=:E631:/
                                return v:false
                              endtry
                            endfunction
                            
    1              0.000001 function! s:VimNotify(method, params) dict abort
                              let request = {'method': a:method, 'params': a:params}
                              call self.AfterInitialized(function('s:Send', [self, request]))
                            endfunction
                            
    1              0.000000 function! s:RequestWait() dict abort
                              while self.status ==# 'running'
                                sleep 1m
                              endwhile
                              while !empty(get(self, 'waiting', {}))
                                sleep 1m
                              endwhile
                              return self
                            endfunction
                            
    1              0.000000 function! s:RequestAwait() dict abort
                              call self.Wait()
                              if has_key(self, 'result')
                                return self.result
                              endif
                              throw 'Copilot:E' . self.error.code . ': ' . self.error.message
                            endfunction
                            
    1              0.000001 function! s:RequestClient() dict abort
                              return get(s:instances, self.client_id, v:null)
                            endfunction
                            
    1              0.000001 if !exists('s:id')
    1              0.000001   let s:id = 0
    1              0.000000 endif
    1              0.000001 if !exists('s:progress_token_id')
    1              0.000001   let s:progress_token_id = 0
    1              0.000000 endif
                            
    1              0.000001 function! s:SetUpRequest(instance, id, method, params, progress, ...) abort
                              let request = {
                                    \ 'client_id': a:instance.id,
                                    \ 'id': a:id,
                                    \ 'method': a:method,
                                    \ 'params': a:params,
                                    \ 'Client': function('s:RequestClient'),
                                    \ 'Wait': function('s:RequestWait'),
                                    \ 'Await': function('s:RequestAwait'),
                                    \ 'Cancel': function('s:RequestCancel'),
                                    \ 'resolve': [],
                                    \ 'reject': [],
                                    \ 'progress': a:progress,
                                    \ 'status': 'running'}
                              let args = a:000[2:-1]
                              if len(args)
                                if !empty(a:1)
                                  call add(request.resolve, { v -> call(a:1, [v] + args)})
                                endif
                                if !empty(a:2)
                                  call add(request.reject, { v -> call(a:2, [v] + args)})
                                endif
                                return request
                              endif
                              if a:0 && !empty(a:1)
                                call add(request.resolve, a:1)
                              endif
                              if a:0 > 1 && !empty(a:2)
                                call add(request.reject, a:2)
                              endif
                              return request
                            endfunction
                            
    1              0.000001 function! s:UrlEncode(str) abort
                              return substitute(iconv(a:str, 'latin1', 'utf-8'),'[^A-Za-z0-9._~!$&''()*+,;=:@/-]','\="%".printf("%02X",char2nr(submatch(0)))','g')
                            endfunction
                            
    1              0.000002 let s:slash = exists('+shellslash') ? '\' : '/'
    1              0.000001 function! s:UriFromBufnr(bufnr) abort
                              let absolute = tr(bufname(a:bufnr), s:slash, '/')
                              if absolute !~# '^\a\+:\|^/\|^$' && getbufvar(a:bufnr, 'buftype') =~# '^\%(nowrite\)\=$'
                                let absolute = substitute(tr(getcwd(), s:slash, '/'), '/\=$', '/', '') . absolute
                              endif
                              return s:UriFromPath(absolute)
                            endfunction
                            
    1              0.000000 function! s:UriFromPath(absolute) abort
                              let absolute = a:absolute
                              if has('win32') && absolute =~# '^\a://\@!'
                                return 'file:///' . strpart(absolute, 0, 2) . s:UrlEncode(strpart(absolute, 2))
                              elseif absolute =~# '^/'
                                return 'file://' . s:UrlEncode(absolute)
                              elseif absolute =~# '^\a[[:alnum:].+-]*:\|^$'
                                return absolute
                              else
                                return ''
                              endif
                            endfunction
                            
    1              0.000001 function! s:BufferText(bufnr) abort
                              return join(getbufline(a:bufnr, 1, '$'), "\n") . "\n"
                            endfunction
                            
    1              0.000001 let s:valid_request_key = '^\%(id\|method\|params\)$'
    1              0.000001 function! s:SendRequest(instance, request, ...) abort
                              if !has_key(a:instance, 'job') || get(a:instance, 'shutdown', a:request) isnot# a:request
                                return s:RejectRequest(a:request, s:error_connection_inactive)
                              endif
                              let json = filter(copy(a:request), 'v:key =~# s:valid_request_key')
                              if empty(s:Send(a:instance, json)) && has_key(a:request, 'id') && has_key(a:instance.requests, a:request.id)
                                call s:RejectRequest(remove(a:instance.requests, a:request.id), {'code': -32099, 'message': 'Write failed'})
                              endif
                            endfunction
                            
    1              0.000001 function! s:RegisterWorkspaceFolderForBuffer(instance, buf) abort
                              let root = getbufvar(a:buf, 'workspace_folder')
                              if type(root) != v:t_string
                                return
                              endif
                              let root = s:UriFromPath(substitute(root, '[\/]$', '', ''))
                              if empty(root) || has_key(a:instance.workspaceFolders, root)
                                return
                              endif
                              let a:instance.workspaceFolders[root] = v:true
                              call a:instance.Notify('workspace/didChangeWorkspaceFolders', {'event': {'added': [{'uri': root, 'name': fnamemodify(root, ':t')}], 'removed': []}})
                            endfunction
                            
    1              0.000001 function! s:PreprocessParams(instance, params) abort
                              let bufnr = v:null
                              for doc in filter([get(a:params, 'textDocument', {})], 'type(get(v:val, "uri", "")) == v:t_number')
                                let bufnr = doc.uri
                                call s:RegisterWorkspaceFolderForBuffer(a:instance, bufnr)
                                call extend(doc, a:instance.Attach(bufnr))
                              endfor
                              let progress_tokens = []
                              for key in keys(a:params)
                                if key =~# 'Token$' && type(a:params[key]) == v:t_func
                                  let s:progress_token_id += 1
                                  let a:instance.progress[s:progress_token_id] = a:params[key]
                                  call add(progress_tokens, s:progress_token_id)
                                  let a:params[key] = s:progress_token_id
                                endif
                              endfor
                              return [bufnr, progress_tokens]
                            endfunction
                            
    1              0.000001 function! s:VimAttach(bufnr) dict abort
                              if !bufloaded(a:bufnr)
                                return {'uri': '', 'version': 0}
                              endif
                              let bufnr = a:bufnr
                              let doc = {
                                    \ 'uri': s:UriFromBufnr(bufnr),
                                    \ 'version': getbufvar(bufnr, 'changedtick', 0),
                                    \ 'languageId': getbufvar(bufnr, '&filetype'),
                                    \ }
                              if has_key(self.open_buffers, bufnr) && (
                                    \ self.open_buffers[bufnr].uri !=# doc.uri ||
                                    \ self.open_buffers[bufnr].languageId !=# doc.languageId)
                                call self.Notify('textDocument/didClose', {'textDocument': {'uri': self.open_buffers[bufnr].uri}})
                                call remove(self.open_buffers, bufnr)
                              endif
                              if !has_key(self.open_buffers, bufnr)
                                call self.Notify('textDocument/didOpen', {'textDocument': extend({'text': s:BufferText(bufnr)}, doc)})
                                let self.open_buffers[bufnr] = doc
                              else
                                call self.Notify('textDocument/didChange', {
                                      \ 'textDocument': {'uri': doc.uri, 'version': doc.version},
                                      \ 'contentChanges': [{'text': s:BufferText(bufnr)}]})
                                let self.open_buffers[bufnr].version = doc.version
                              endif
                              return doc
                            endfunction
                            
    1              0.000001 function! s:VimIsAttached(bufnr) dict abort
                              return bufloaded(a:bufnr) && has_key(self.open_buffers, a:bufnr) ? v:true : v:false
                            endfunction
                            
    1              0.000001 function! s:VimRequest(method, params, ...) dict abort
                              let s:id += 1
                              let params = deepcopy(a:params)
                              let [_, progress] = s:PreprocessParams(self, params)
                              let request = call('s:SetUpRequest', [self, s:id, a:method, params, progress] + a:000)
                              call self.AfterInitialized(function('s:SendRequest', [self, request]))
                              let self.requests[s:id] = request
                              return request
                            endfunction
                            
    1              0.000001 function! s:Call(method, params, ...) dict abort
                              let request = call(self.Request, [a:method, a:params] + a:000)
                              if a:0
                                return request
                              endif
                              return request.Await()
                            endfunction
                            
    1              0.000000 function! s:Cancel(request) dict abort
                              if has_key(self.requests, get(a:request, 'id', ''))
                                call self.Notify('$/cancelRequest', {'id': a:request.id})
                                call s:RejectRequest(remove(self.requests, a:request.id), s:error_canceled)
                              endif
                            endfunction
                            
    1              0.000000 function! s:RequestCancel() dict abort
                              let instance = self.Client()
                              if !empty(instance)
                                call instance.Cancel(self)
                              elseif get(self, 'status', '') ==# 'running'
                                call s:RejectRequest(self, s:error_canceled)
                              endif
                              return self
                            endfunction
                            
    1              0.000001 function! s:DispatchMessage(instance, method, handler, id, params, ...) abort
                              try
                                let response = {'result': call(a:handler, [a:params, a:instance])}
                                if response.result is# 0
                                  let response.result = v:null
                                endif
                              catch
                                call copilot#logger#Exception('lsp.request.' . a:method)
                                let response = {'error': {'code': -32000, 'message': v:exception}}
                              endtry
                              if a:id isnot# v:null
                                call s:Send(a:instance, extend({'id': a:id}, response))
                              endif
                              if !has_key(s:notifications, a:method)
                                return response
                              endif
                            endfunction
                            
    1              0.000001 function! s:OnMessage(instance, body, ...) abort
                              if !has_key(a:body, 'method')
                                return s:OnResponse(a:instance, a:body)
                              endif
                              let request = a:body
                              let id = get(request, 'id', v:null)
                              let params = get(request, 'params', v:null)
                              if has_key(a:instance.methods, request.method)
                                return s:DispatchMessage(a:instance, request.method, a:instance.methods[request.method], id, params)
                              elseif id isnot# v:null
                                call s:Send(a:instance, {"id": id, "error": {"code": -32700, "message": "Method not found: " . request.method}})
                                call copilot#logger#Debug('Unexpected request ' . request.method . ' called with ' . json_encode(params))
                              elseif request.method !~# '^\$/'
                                call copilot#logger#Debug('Unexpected notification ' . request.method . ' called with ' . json_encode(params))
                              endif
                            endfunction
                            
    1              0.000001 function! s:OnResponse(instance, response, ...) abort
                              let response = a:response
                              let id = get(a:response, 'id', v:null)
                              if !has_key(a:instance.requests, id)
                                return
                              endif
                              let request = remove(a:instance.requests, id)
                              for progress_token in request.progress
                                if has_key(a:instance.progress, progress_token)
                                  call remove(a:instance.progress, progress_token)
                                endif
                              endfor
                              if request.status !=# 'running'
                                return
                              endif
                              if has_key(response, 'result')
                                let request.waiting = {}
                                let resolve = remove(request, 'resolve')
                                call remove(request, 'reject')
                                let request.status = 'success'
                                let request.result = response.result
                                for Cb in resolve
                                  let request.waiting[timer_start(0, function('s:Callback', [request, 'result', Cb]))] = 1
                                endfor
                              else
                                call s:RejectRequest(request, response.error)
                              endif
                            endfunction
                            
    1              0.000001 function! s:OnErr(instance, ch, line, ...) abort
                              if !has_key(a:instance, 'serverInfo')
                                call copilot#logger#Bare('<-! ' . a:line)
                              endif
                            endfunction
                            
    1              0.000001 function! s:OnExit(instance, code, ...) abort
                              let a:instance.exit_status = a:code
                              if has_key(a:instance, 'job')
                                call remove(a:instance, 'job')
                              endif
                              if has_key(a:instance, 'client_id')
                                call remove(a:instance, 'client_id')
                              endif
                              let message = 'Process exited with status ' . a:code
                              if a:code >= 18 && a:code < 100
                                let message = 'Node.js too old.  ' .
                                      \ (get(a:instance.node, 0, 'node') ==# 'node' ? 'Upgrade' : 'Change g:copilot_node_command') .
                                      \ ' to ' . a:code . '.x or newer'
                              endif
                              if !has_key(a:instance, 'serverInfo') && !has_key(a:instance, 'startup_error')
                                let a:instance.startup_error = message
                              endif
                              for id in sort(keys(a:instance.requests), { a, b -> +a > +b })
                                call s:RejectRequest(remove(a:instance.requests, id), s:error_exit)
                              endfor
                              if has_key(a:instance, 'after_initialized')
                                let a:instance.AfterInitialized = function('copilot#util#Defer')
                                for Fn in remove(a:instance, 'after_initialized')
                                  call copilot#util#Defer(Fn)
                                endfor
                              endif
                              call copilot#util#Defer({ -> get(s:instances, a:instance.id) is# a:instance ? remove(s:instances, a:instance.id) : {} })
                              if a:code == 0
                                call copilot#logger#Info(message)
                              else
                                call copilot#logger#Warn(message)
                                if !has_key(a:instance, 'kill')
                                  call copilot#util#Defer(function('s:Warn'), message)
                                endif
                              endif
                            endfunction
                            
    1              0.000001 function! copilot#client#LspInit(id, initialize_result) abort
                              if !has_key(s:instances, a:id)
                                return
                              endif
                              call s:PostInit(a:initialize_result, s:instances[a:id])
                            endfunction
                            
    1              0.000001 function! copilot#client#LspExit(id, code, signal) abort
                              if !has_key(s:instances, a:id)
                                return
                              endif
                              let instance = remove(s:instances, a:id)
                              call s:OnExit(instance, a:code)
                            endfunction
                            
    1              0.000001 function! copilot#client#LspResponse(id, opts, ...) abort
                              if !has_key(s:instances, a:id)
                                return
                              endif
                              call s:OnResponse(s:instances[a:id], a:opts)
                            endfunction
                            
    1              0.000001 function! s:NvimAttach(bufnr) dict abort
                              if !bufloaded(a:bufnr)
                                return {'uri': '', 'version': 0}
                              endif
                              call luaeval('pcall(vim.lsp.buf_attach_client, _A[1], _A[2])', [a:bufnr, self.id])
                              return luaeval('{uri = vim.uri_from_bufnr(_A), version = vim.lsp.util.buf_versions[_A]}', a:bufnr)
                            endfunction
                            
    1              0.000001 function! s:NvimIsAttached(bufnr) dict abort
                              return bufloaded(a:bufnr) ? luaeval('vim.lsp.buf_is_attached(_A[1], _A[2])', [a:bufnr, self.id]) : v:false
                            endfunction
                            
    1              0.000001 function! s:NvimRequest(method, params, ...) dict abort
                              let params = deepcopy(a:params)
                              let [bufnr, progress] = s:PreprocessParams(self, params)
                              let request = call('s:SetUpRequest', [self, v:null, a:method, params, progress] + a:000)
                              call self.AfterInitialized(function('s:NvimDoRequest', [self, request, bufnr]))
                              return request
                            endfunction
                            
    1              0.000001 function! s:NvimDoRequest(client, request, bufnr) abort
                              let request = a:request
                              if has_key(a:client, 'client_id') && !has_key(a:client, 'kill')
                                let request.id = eval("v:lua.require'_copilot'.lsp_request(a:client.id, a:request.method, a:request.params, a:bufnr)")
                              endif
                              if request.id isnot# v:null
                                let a:client.requests[request.id] = request
                              else
                                if has_key(a:client, 'client_id')
                                  call copilot#client#LspExit(a:client.client_id, -1, -1)
                                endif
                                call copilot#util#Defer(function('s:RejectRequest'), request, s:error_connection_inactive)
                              endif
                              return request
                            endfunction
                            
    1              0.000000 function! s:NvimClose() dict abort
                              if !has_key(self, 'client_id')
                                return
                              endif
                              let self.kill = v:true
                              return luaeval('vim.lsp.get_client_by_id(_A).stop()', self.client_id)
                            endfunction
                            
    1              0.000001 function! s:NvimNotify(method, params) dict abort
                              call self.AfterInitialized(function('s:NvimDoNotify', [self.client_id, a:method, a:params]))
                            endfunction
                            
    1              0.000001 function! s:NvimDoNotify(client_id, method, params) abort
                              return eval("v:lua.require'_copilot'.rpc_notify(a:client_id, a:method, a:params)")
                            endfunction
                            
    1              0.000001 function! copilot#client#LspHandle(id, request) abort
                              if !has_key(s:instances, a:id)
                                return
                              endif
                              return s:OnMessage(s:instances[a:id], a:request)
                            endfunction
                            
    1              0.000001 let s:script_name = 'dist/language-server.js'
    1              0.000000 function! s:Command() abort
                              if !has('nvim-0.7') && v:version < 900
                                return [[], [], 'Vim version too old']
                              endif
                              let script = get(g:, 'copilot_command', '')
                              if type(script) == type('')
                                let script = [expand(script)]
                              endif
                              if empty(script) || !filereadable(script[0])
                                let script = [s:root . '/' . s:script_name]
                                if !filereadable(script[0])
                                  return [[], [], 'Could not find ' . s:script_name . ' (bad install?)']
                                endif
                              elseif script[0] !~# '\.js$'
                                return [[], script + ['--stdio'], '']
                              endif
                              let node = get(g:, 'copilot_node_command', '')
                              if empty(node)
                                let node = ['node']
                              elseif type(node) == type('')
                                let node = [expand(node)]
                              endif
                              if !executable(get(node, 0, ''))
                                if get(node, 0, '') ==# 'node'
                                  return [[], [], 'Node.js not found in PATH']
                                else
                                  return [[], [], 'Node.js executable `' . get(node, 0, '') . "' not found"]
                                endif
                              endif
                              return [node, script + ['--stdio'], '']
                            endfunction
                            
    1              0.000001 function! s:UrlDecode(str) abort
                              return substitute(a:str, '%\(\x\x\)', '\=iconv(nr2char("0x".submatch(1)), "utf-8", "latin1")', 'g')
                            endfunction
                            
    1              0.000001 function! copilot#client#EditorInfo() abort
                              if !exists('s:editor_version')
                                if has('nvim')
                                  let s:editor_version = matchstr(execute('version'), 'NVIM v\zs[^[:space:]]\+')
                                else
                                  let s:editor_version = (v:version / 100) . '.' . (v:version % 100) . (exists('v:versionlong') ? printf('.%04d', v:versionlong % 10000) : '')
                                endif
                              endif
                              return {'name': has('nvim') ? 'Neovim': 'Vim', 'version': s:editor_version}
                            endfunction
                            
    1              0.000001 function! copilot#client#EditorPluginInfo() abort
                              return {'name': 'copilot.vim', 'version': s:plugin_version}
                            endfunction
                            
    1              0.000000 function! copilot#client#Settings() abort
                              let settings = {
                                    \ 'http': {
                                    \   'proxy': get(g:, 'copilot_proxy', v:null),
                                    \   'proxyStrictSSL': get(g:, 'copilot_proxy_strict_ssl', v:null)},
                                    \ 'github-enterprise': {'uri': get(g:, 'copilot_auth_provider_url', v:null)},
                                    \ }
                              if type(settings.http.proxy) ==# v:t_string && settings.http.proxy =~# '^[^/]\+$'
                                let settings.http.proxy = 'http://' . settings.http.proxy
                              endif
                              if type(get(g:, 'copilot_settings')) == v:t_dict
                                call extend(settings, g:copilot_settings)
                              endif
                              return settings
                            endfunction
                            
    1              0.000001 function! s:PostInit(result, instance) abort
                              let a:instance.serverInfo = get(a:result, 'serverInfo', {})
                              if !has_key(a:instance, 'node_version') && has_key(a:result.serverInfo, 'nodeVersion')
                                let a:instance.node_version = a:result.serverInfo.nodeVersion
                              endif
                              let a:instance.AfterInitialized = function('copilot#util#Defer')
                              for Fn in remove(a:instance, 'after_initialized')
                                call copilot#util#Defer(Fn)
                              endfor
                            endfunction
                            
    1              0.000001 function! s:InitializeResult(result, instance) abort
                              call s:Send(a:instance, {'method': 'initialized', 'params': {}})
                              call s:PostInit(a:result, a:instance)
                            endfunction
                            
    1              0.000001 function! s:InitializeError(error, instance) abort
                              if !has_key(a:instance, 'startup_error')
                                let a:instance.startup_error = 'Unexpected error E' . a:error.code . ' initializing language server: ' . a:error.message
                                call a:instance.Close()
                              endif
                            endfunction
                            
    1              0.000000 function! s:StartupError() dict abort
                              while (has_key(self, 'job') || has_key(self, 'client_id')) && !has_key(self, 'startup_error') && !has_key(self, 'serverInfo')
                                sleep 10m
                              endwhile
                              if has_key(self, 'serverInfo')
                                return ''
                              else
                                return get(self, 'startup_error', 'Something unexpected went wrong spawning the language server')
                              endif
                            endfunction
                            
    1              0.000001 function! s:StatusNotification(params, instance) abort
                              let a:instance.status = a:params
                            endfunction
                            
    1              0.000000 function! s:Nop(...) abort
                              return v:null
                            endfunction
                            
    1              0.000000 function! s:False(...) abort
                              return v:false
                            endfunction
                            
    1              0.000001 function! s:Progress(params, instance) abort
                              if has_key(a:instance.progress, a:params.token)
                                call a:instance.progress[a:params.token](a:params.value)
                              endif
                            endfunction
                            
    1              0.000007 let s:notifications = {
                                  \ '$/progress': function('s:Progress'),
                                  \ 'featureFlagsNotification': function('s:Nop'),
                                  \ 'statusNotification': function('s:StatusNotification'),
                                  \ 'window/logMessage': function('copilot#handlers#window_logMessage'),
                                  \ }
                            
    1              0.000003 let s:vim_handlers = {
                                  \ 'window/showMessageRequest': function('copilot#handlers#window_showMessageRequest'),
                                  \ 'window/showDocument': function('copilot#handlers#window_showDocument'),
                                  \ }
                            
    1              0.000004 let s:vim_capabilities = {
                                  \ 'workspace': {'workspaceFolders': v:true},
                                  \ 'window': {'showDocument': {'support': v:true}},
                                  \ }
                            
    1              0.000001 function! copilot#client#New(...) abort
                              let opts = a:0 ? a:1 : {}
                              let instance = {'requests': {},
                                    \ 'progress': {},
                                    \ 'workspaceFolders': {},
                                    \ 'after_initialized': [],
                                    \ 'status': {'status': 'Starting', 'message': ''},
                                    \ 'AfterInitialized': function('s:AfterInitialized'),
                                    \ 'Close': function('s:Nop'),
                                    \ 'Notify': function('s:False'),
                                    \ 'Request': function('s:VimRequest'),
                                    \ 'Attach': function('s:Nop'),
                                    \ 'IsAttached': function('s:False'),
                                    \ 'Call': function('s:Call'),
                                    \ 'Cancel': function('s:Cancel'),
                                    \ 'StartupError': function('s:StartupError'),
                                    \ }
                              let instance.methods = copy(s:notifications)
                              let [node, argv, command_error] = s:Command()
                              if !empty(command_error)
                                let instance.id = -1
                                let instance.startup_error = command_error
                                call copilot#logger#Error(command_error)
                                return instance
                              endif
                              let instance.node = node
                              let command = node + argv
                              let opts = {}
                              let opts.initializationOptions = {
                                    \ 'editorInfo': copilot#client#EditorInfo(),
                                    \ 'editorPluginInfo': copilot#client#EditorPluginInfo(),
                                    \ }
                              let opts.workspaceFolders = []
                              let settings = extend(copilot#client#Settings(), get(opts, 'editorConfiguration', {}))
                              if type(get(g:, 'copilot_workspace_folders')) == v:t_list
                                for folder in g:copilot_workspace_folders
                                  if type(folder) == v:t_string && !empty(folder) && folder !~# '\*\*\|^/$'
                                    for path in glob(folder . '/', 0, 1)
                                      let uri = s:UriFromPath(substitute(path, '[\/]*$', '', ''))
                                      call add(opts.workspaceFolders, {'uri': uri, 'name': fnamemodify(uri, ':t')})
                                    endfor
                                  elseif type(folder) == v:t_dict && has_key(v:t_dict, 'uri') && !empty(folder.uri) && has_key(folder, 'name')
                                    call add(opts.workspaceFolders, folder)
                                  endif
                                endfor
                              endif
                              for folder in opts.workspaceFolders
                                let instance.workspaceFolders[folder.uri] = v:true
                              endfor
                              if has('nvim')
                                call extend(instance, {
                                      \ 'Close': function('s:NvimClose'),
                                      \ 'Notify': function('s:NvimNotify'),
                                      \ 'Request': function('s:NvimRequest'),
                                      \ 'Attach': function('s:NvimAttach'),
                                      \ 'IsAttached': function('s:NvimIsAttached'),
                                      \ })
                                let instance.client_id = eval("v:lua.require'_copilot'.lsp_start_client(command, keys(instance.methods), opts, settings)")
                                let instance.id = instance.client_id
                              else
                                call extend(instance, {
                                      \ 'Close': function('s:VimClose'),
                                      \ 'Notify': function('s:VimNotify'),
                                      \ 'Attach': function('s:VimAttach'),
                                      \ 'IsAttached': function('s:VimIsAttached'),
                                      \ })
                                let state = {'headers': {}, 'mode': 'headers', 'buffer': ''}
                                let instance.open_buffers = {}
                                let instance.methods = extend(s:vim_handlers, instance.methods)
                                let instance.job = job_start(command, {
                                      \ 'cwd': copilot#job#Cwd(),
                                      \ 'noblock': 1,
                                      \ 'stoponexit': '',
                                      \ 'in_mode': 'lsp',
                                      \ 'out_mode': 'lsp',
                                      \ 'out_cb': { j, d -> copilot#util#Defer(function('s:OnMessage'), instance, d) },
                                      \ 'err_cb': function('s:OnErr', [instance]),
                                      \ 'exit_cb': { j, d -> copilot#util#Defer(function('s:OnExit'), instance, d) },
                                      \ })
                                let instance.id = job_info(instance.job).process
                                let opts.capabilities = s:vim_capabilities
                                let opts.processId = getpid()
                                let request = instance.Request('initialize', opts, function('s:InitializeResult'), function('s:InitializeError'), instance)
                                call call(remove(instance.after_initialized, 0), [])
                                call instance.Notify('workspace/didChangeConfiguration', {'settings': settings})
                              endif
                              let s:instances[instance.id] = instance
                              return instance
                            endfunction
                            
    1              0.000001 function! copilot#client#Cancel(request) abort
                              if type(a:request) == type({}) && has_key(a:request, 'Cancel')
                                call a:request.Cancel()
                              endif
                            endfunction
                            
    1              0.000001 function! s:Callback(request, type, callback, timer) abort
                              call remove(a:request.waiting, a:timer)
                              if has_key(a:request, a:type)
                                call a:callback(a:request[a:type])
                              endif
                            endfunction
                            
    1              0.000001 function! copilot#client#Result(request, callback) abort
                              if has_key(a:request, 'resolve')
                                call add(a:request.resolve, a:callback)
                              elseif has_key(a:request, 'result')
                                let a:request.waiting[timer_start(0, function('s:Callback', [a:request, 'result', a:callback]))] = 1
                              endif
                            endfunction
                            
    1              0.000001 function! copilot#client#Error(request, callback) abort
                              if has_key(a:request, 'reject')
                                call add(a:request.reject, a:callback)
                              elseif has_key(a:request, 'error')
                                let a:request.waiting[timer_start(0, function('s:Callback', [a:request, 'error', a:callback]))] = 1
                              endif
                            endfunction
                            
    1              0.000001 function! s:CloseBuffer(bufnr) abort
                              for instance in values(s:instances)
                                try
                                  if has_key(instance, 'job') && has_key(instance.open_buffers, a:bufnr)
                                    let buffer = remove(instance.open_buffers, a:bufnr)
                                    call instance.Notify('textDocument/didClose', {'textDocument': {'uri': buffer.uri}})
                                  endif
                                catch
                                  call copilot#logger#Exception()
                                endtry
                              endfor
                            endfunction
                            
    1              0.000001 augroup copilot_close
    1              0.000008   autocmd!
    1              0.000001   if !has('nvim')
                                autocmd BufUnload * call s:CloseBuffer(+expand('<abuf>'))
    1              0.000000   endif
    1              0.000001 augroup END

SCRIPT  /Users/brunosilveira/.local/share/nvim/lazy/copilot.vim/autoload/copilot/version.vim
Sourced 1 time
Total time:   0.000220
 Self time:   0.000220

count  total (s)   self (s)
    1              0.000002 function! copilot#version#String() abort
                              return '1.41.0'
                            endfunction

SCRIPT  /Users/brunosilveira/.local/share/nvim/lazy/copilot.vim/autoload/copilot/job.vim
Sourced 1 time
Total time:   0.000244
 Self time:   0.000244

count  total (s)   self (s)
    1              0.000001 scriptencoding utf-8
                            
    1              0.000001 function! copilot#job#Nop(...) abort
                            endfunction
                            
    1              0.000001 function! s:Jobs(job_or_jobs) abort
                              let jobs = type(a:job_or_jobs) == v:t_list ? copy(a:job_or_jobs) : [a:job_or_jobs]
                              call map(jobs, { k, v -> type(v) == v:t_dict ? get(v, 'job', '') : v })
                              call filter(jobs, { k, v -> type(v) !=# type('') })
                              return jobs
                            endfunction
                            
    1              0.000002 let s:job_stop = exists('*job_stop') ? 'job_stop' : 'jobstop'
    1              0.000001 function! copilot#job#Stop(job) abort
                              for job in s:Jobs(a:job)
                                call call(s:job_stop, [job])
                              endfor
                              return copilot#job#Wait(a:job)
                            endfunction
                            
    1              0.000002 let s:sleep = has('patch-8.2.2366') ? 'sleep! 1m' : 'sleep 1m'
    1              0.000001 function! copilot#job#Wait(jobs) abort
                              let jobs = s:Jobs(a:jobs)
                              if exists('*jobwait')
                                call jobwait(jobs)
                              else
                                for job in jobs
                                  while ch_status(job) !=# 'closed' || job_status(job) ==# 'run'
                                    exe s:sleep
                                  endwhile
                                endfor
                              endif
                              return a:jobs
                            endfunction
                            
    1              0.000001 function! s:VimExitCallback(result, exit_cb, job, data) abort
                              let a:result.exit_status = a:data
                              if !has_key(a:result, 'closed')
                                return
                              endif
                              call remove(a:result, 'closed')
                              call a:exit_cb(a:result.exit_status)
                            endfunction
                            
    1              0.000001 function! s:VimCloseCallback(result, exit_cb, job) abort
                              if !has_key(a:result, 'exit_status')
                                let a:result.closed = v:true
                                return
                              endif
                              call a:exit_cb(a:result.exit_status)
                            endfunction
                            
    1              0.000001 function! s:NvimCallback(cb, job, data, type) dict abort
                              let self[a:type][0] .= remove(a:data, 0)
                              call extend(self[a:type], a:data)
                              while len(self[a:type]) > 1
                                call a:cb(substitute(remove(self[a:type], 0), "\r$", '', ''))
                              endwhile
                            endfunction
                            
    1              0.000001 function! s:NvimExitCallback(out_cb, err_cb, exit_cb, job, data, type) dict abort
                              if len(self.stderr[0])
                                call a:err_cb(substitute(self.stderr[0], "\r$", '', ''))
                              endif
                              call a:exit_cb(a:data)
                            endfunction
                            
    1              0.000001 function! copilot#job#Cwd() abort
                              let home = expand("~")
                              if !isdirectory(home) && isdirectory($VIM)
                                return $VIM
                              endif
                              return home
                            endfunction
                            
    1              0.000001 function! copilot#job#Stream(argv, out_cb, err_cb, ...) abort
                              let exit_status = []
                              let ExitCb = function(a:0 && !empty(a:1) ? a:1 : { e -> add(exit_status, e) }, a:000[2:-1])
                              let OutCb = function(empty(a:out_cb) ? 'copilot#job#Nop' : a:out_cb, a:000[2:-1])
                              let ErrCb = function(empty(a:err_cb) ? 'copilot#job#Nop' : a:err_cb, a:000[2:-1])
                              let state = {'headers': {}, 'mode': 'headers', 'buffer': ''}
                              if exists('*job_start')
                                let result = {}
                                let job = job_start(a:argv, {
                                      \ 'cwd': copilot#job#Cwd(),
                                      \ 'out_mode': 'raw',
                                      \ 'out_cb': { j, d -> OutCb(d) },
                                      \ 'err_cb': { j, d -> ErrCb(d) },
                                      \ 'exit_cb': function('s:VimExitCallback', [result, ExitCb]),
                                      \ 'close_cb': function('s:VimCloseCallback', [result, ExitCb]),
                                      \ })
                              else
                                let jopts = {
                                      \ 'cwd': copilot#job#Cwd(),
                                      \ 'stderr': [''],
                                      \ 'on_stdout': { j, d, t -> OutCb(join(d, "\n")) },
                                      \ 'on_stderr': function('s:NvimCallback', [ErrCb]),
                                      \ 'on_exit': function('s:NvimExitCallback', [OutCb, ErrCb, ExitCb])}
                                let job = jobstart(a:argv, jopts)
                              endif
                              if a:0
                                return job
                              endif
                              call copilot#job#Wait(job)
                              return exit_status[0]
                            endfunction

SCRIPT  /Users/brunosilveira/.local/share/nvim/lazy/copilot.vim/autoload/copilot/handlers.vim
Sourced 1 time
Total time:   0.000183
 Self time:   0.000183

count  total (s)   self (s)
    1              0.000003 function! copilot#handlers#window_logMessage(params, ...) abort
                              call copilot#logger#Raw(get(a:params, 'type', 6), get(a:params, 'message', ''))
                            endfunction
                            
    1              0.000001 function! copilot#handlers#window_showMessageRequest(params, ...) abort
                              let choice = inputlist([a:params.message . "\n\nRequest Actions:"] +
                                    \ map(copy(get(a:params, 'actions', [])), { i, v -> (i + 1) . '. ' . v.title}))
                              return choice > 0 ? get(a:params.actions, choice - 1, v:null) : v:null
                            endfunction
                            
    1              0.000001 function! s:BrowserCallback(into, code) abort
                              let a:into.code = a:code
                            endfunction
                            
    1              0.000001 function! copilot#handlers#window_showDocument(params, ...) abort
                              echo a:params.uri
                              if empty(get(a:params, 'external'))
                                return {'success': v:false}
                              endif
                              let browser = copilot#Browser()
                              if empty(browser)
                                return {'success': v:false}
                              endif
                              let status = {}
                              call copilot#job#Stream(browser + [a:params.uri], v:null, v:null, function('s:BrowserCallback', [status]))
                              let time = reltime()
                              while empty(status) && reltimefloat(reltime(time)) < 1
                                sleep 10m
                              endwhile
                              return {'success': get(status, 'code') ? v:false : v:true}
                            endfunction

SCRIPT  /Users/brunosilveira/.local/share/nvim/lazy/copilot.vim/autoload/copilot/logger.vim
Sourced 1 time
Total time:   0.009273
 Self time:   0.009273

count  total (s)   self (s)
    1              0.000002 if !exists('s:log_file')
    1              0.000014   let s:log_file = tempname() . '-copilot.log'
    1              0.000001   try
    1              0.009073     call writefile([], s:log_file)
                              catch
    1              0.000001   endtry
    1              0.000000 endif
                            
    1              0.000004 let s:logs = []
                            
    1              0.000002 function! copilot#logger#BufReadCmd() abort
                              try
                                setlocal modifiable noreadonly
                                silent call deletebufline('', 1, '$')
                                if !empty(s:logs)
                                  call setline(1, s:logs)
                                endif
                              finally
                                setlocal buftype=nofile bufhidden=wipe nobuflisted nomodified nomodifiable
                              endtry
                            endfunction
                            
    1              0.000002 let s:level_prefixes = ['', '[ERROR] ', '[WARN] ', '[INFO] ', '[DEBUG] ', '[DEBUG] ']
                            
    1              0.000001 function! copilot#logger#Raw(level, message) abort
                              let lines = type(a:message) == v:t_list ? copy(a:message) : split(a:message, "\n", 1)
                              let lines[0] = strftime('[%Y-%m-%d %H:%M:%S] ') . get(s:level_prefixes, a:level, '[UNKNOWN] ') . get(lines, 0, '')
                              try
                                if !filewritable(s:log_file)
                                  return
                                endif
                                call map(lines, { k, L -> type(L) == v:t_func ? call(L, []) : L })
                                call extend(s:logs, lines)
                                let overflow = len(s:logs) - get(g:, 'copilot_log_history', 10000)
                                if overflow > 0
                                  call remove(s:logs, 0, overflow - 1)
                                endif
                                let bufnr = bufnr('copilot:///log')
                                if bufnr > 0 && bufloaded(bufnr)
                                  call setbufvar(bufnr, '&modifiable', 1)
                                  call setbufline(bufnr, 1, s:logs)
                                  call setbufvar(bufnr, '&modifiable', 0)
                                  for winid in win_findbuf(bufnr)
                                    if has('nvim') && winid != win_getid()
                                      call nvim_win_set_cursor(winid, [len(s:logs), 0])
                                    endif
                                  endfor
                                endif
                              catch
                              endtry
                            endfunction
                            
    1              0.000001 function! copilot#logger#Debug(...) abort
                              if empty(get(g:, 'copilot_debug'))
                                return
                              endif
                              call copilot#logger#Raw(4, a:000)
                            endfunction
                            
    1              0.000000 function! copilot#logger#Info(...) abort
                              call copilot#logger#Raw(3, a:000)
                            endfunction
                            
    1              0.000000 function! copilot#logger#Warn(...) abort
                              call copilot#logger#Raw(2, a:000)
                            endfunction
                            
    1              0.000000 function! copilot#logger#Error(...) abort
                              call copilot#logger#Raw(1, a:000)
                            endfunction
                            
    1              0.000000 function! copilot#logger#Bare(...) abort
                              call copilot#logger#Raw(0, a:000)
                            endfunction
                            
    1              0.000001 function! copilot#logger#Exception(...) abort
                              if !empty(v:exception) && v:exception !=# 'Vim:Interrupt'
                                call copilot#logger#Error('Exception: ' . v:exception . ' @ ' . v:throwpoint)
                                let client = copilot#RunningClient()
                                if !empty(client)
                                  let [_, type, code, message; __] = matchlist(v:exception, '^\%(\(^[[:alnum:]_#]\+\)\%((\a\+)\)\=\%(\(:E-\=\d\+\)\)\=:\s*\)\=\(.*\)$')
                                  let stacklines = []
                                  for frame in split(substitute(v:throwpoint, ', \S\+ \(\d\+\)$', '[\1]', ''), '\.\@<!\.\.\.\@!')
                                    let fn_line = matchlist(frame, '^\%(function \)\=\(\S\+\)\[\(\d\+\)\]$')
                                    if !empty(fn_line)
                                      call add(stacklines, {'function': substitute(fn_line[1], '^<SNR>\d\+_', '<SID>', ''), 'lineno': +fn_line[2]})
                                    elseif frame =~# ' Autocmds for "\*"$'
                                      call add(stacklines, {'function': frame})
                                    elseif frame =~# ' Autocmds for ".*"$'
                                      call add(stacklines, {'function': substitute(frame, ' for ".*"$', ' for "[redacted]"', '')})
                                    else
                                      call add(stacklines, {'function': '[redacted]'})
                                    endif
                                  endfor
                                  return client.Request('telemetry/exception', {
                                        \ 'transaction': a:0 ? a:1 : '',
                                        \ 'platform': 'other',
                                        \ 'exception_detail': [{
                                        \ 'type': type . code,
                                        \ 'value': message,
                                        \ 'stacktrace': stacklines}]
                                        \ }, v:null, function('copilot#util#Nop'))
                                endif
                              endif
                            endfunction

FUNCTION  <SNR>58_NvimAttach()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/client.vim:431
Called 7 times
Total time:   0.000969
 Self time:   0.000691

count  total (s)   self (s)
    7              0.000008   if !bufloaded(a:bufnr)
                                return {'uri': '', 'version': 0}
    7              0.000002   endif
    7   0.000815   0.000537   call luaeval('pcall(vim.lsp.buf_attach_client, _A[1], _A[2])', [a:bufnr, self.id])
    7              0.000129   return luaeval('{uri = vim.uri_from_bufnr(_A), version = vim.lsp.util.buf_versions[_A]}', a:bufnr)

FUNCTION  3()
    Defined: /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/autoload/provider/clipboard.vim:184
Called 2 times
Total time:   0.032808
 Self time:   0.000066

count  total (s)   self (s)
    2              0.000003   if a:reg == '"'
                                call s:clipboard.set(a:lines,a:regtype,'+')
                                if s:copy['*'] != s:copy['+']
                                  call s:clipboard.set(a:lines,a:regtype,'*')
                                end
                                return 0
    2              0.000001   end
                            
    2              0.000005   if type(s:copy[a:reg]) == v:t_func
                                call s:copy[a:reg](a:lines, a:regtype)
                                return 0
    2              0.000001   end
                            
    2              0.000002   if s:cache_enabled == 0
    2   0.032756   0.000015     call s:try_cmd(s:copy[a:reg], a:lines)
                                "Cache it anyway we can compare it later to get regtype of the yank
    2              0.000016     let s:selections[a:reg] = copy(s:selection)
    2              0.000003     let s:selections[a:reg].data = [a:lines, a:regtype]
    2              0.000001     return 0
                              end
                            
                              if s:selections[a:reg].owner > 0
                                let prev_job = s:selections[a:reg].owner
                              end
                              let s:selections[a:reg] = copy(s:selection)
                              let selection = s:selections[a:reg]
                              let selection.data = [a:lines, a:regtype]
                              let selection.argv = s:copy[a:reg]
                              let selection.detach = s:cache_enabled
                              let selection.cwd = "/"
                              let jobid = jobstart(selection.argv, selection)
                              if jobid > 0
                                call jobsend(jobid, a:lines)
                                call jobclose(jobid, 'stdin')
                                " xclip does not close stdout when receiving input via stdin
                                if selection.argv[0] ==# 'xclip'
                                  call jobclose(jobid, 'stdout')
                                endif
                                let selection.owner = jobid
                                let ret = 1
                              else
                                echohl WarningMsg
                                echomsg 'clipboard: failed to execute: '.(s:copy[a:reg])
                                echohl None
                                let ret = 1
                              endif
                            
                              " The previous provider instance should exit when the new one takes
                              " ownership, but kill it to be sure we don't fill up the job table.
                              if exists('prev_job')
                                call timer_start(1000, {... -> jobwait([prev_job], 0)[0] == -1 && jobstop(prev_job)})
                              endif
                            
                              return ret

FUNCTION  <SNR>52_MapTab()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/plugin/copilot.vim:23
Called 1 time
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    1              0.000002   if get(g:, 'copilot_no_tab_map') || get(g:, 'copilot_no_maps')
                                return
    1              0.000000   endif
    1              0.000007   let tab_map = maparg('<Tab>', 'i', 0, 1)
    1              0.000001   if !has_key(tab_map, 'rhs')
    1              0.000003     imap <script><silent><nowait><expr> <Tab> empty(get(g:, 'copilot_no_tab_map')) ? copilot#Accept() : "\t"
                              elseif tab_map.rhs !~# 'copilot'
                                if tab_map.expr
                                  let tab_fallback = '{ -> ' . tab_map.rhs . ' }'
                                else
                                  let tab_fallback = substitute(json_encode(tab_map.rhs), '<', '\\<', 'g')
                                endif
                                let tab_fallback = substitute(tab_fallback, '<SID>', '<SNR>' . get(tab_map, 'sid') . '_', 'g')
                                if get(tab_map, 'noremap') || get(tab_map, 'script') || mapcheck('<Left>', 'i') || mapcheck('<Del>', 'i')
                                  exe 'imap <script><silent><nowait><expr> <Tab> copilot#Accept(' . tab_fallback . ')'
                                else
                                  exe 'imap <silent><nowait><expr>         <Tab> copilot#Accept(' . tab_fallback . ')'
                                endif
    1              0.000000   endif

FUNCTION  RailsDetect()
    Defined: ~/.local/share/nvim/lazy/vim-rails/plugin/rails.vim:34
Called 14 times
Total time:   0.002303
 Self time:   0.002238

count  total (s)   self (s)
   14              0.000020   if exists('b:rails_root')
                                return 1
   14              0.000004   endif
   14              0.000006   if a:0
                                let path = a:1
   14   0.000138   0.000110   elseif &l:buftype =~# '^\%(nowrite\)\=$' && len(@%) || &l:buftype =~# '^\%(nofile\|acwrite\)' && s:IsAbs(@%)
    6              0.000006     let path = @%
    8              0.000002   else
    8              0.000003     return
    6              0.000002   endif
    6   0.000058   0.000021   if !s:IsAbs(path)
    6              0.000011     let s = exists('+shellslash') && !&shellslash ? '\' : '/'
    6              0.000339     let path = substitute(getcwd(), '\' . s . '\=$', s, '') . path
    6              0.000008   endif
    6              0.000042   let path = substitute(path, '[' . s:slash . '/]$', '', '')
    6              0.000004   try
    6              0.000018     if exists('*ExcludeBufferFromDiscovery') && ExcludeBufferFromDiscovery(file, 'projectionist')
                                  return
    6              0.000002     endif
                              catch
    6              0.000003   endtry
                            
    6              0.000007   if exists('*ProjectionistHas')
                                let previous = ''
                                while path !=# previous && path !~# '^\.\=$\|^[\/][\/][^\/]*$'
                                  if ProjectionistHas('config/environment.rb&app/', path)
                                    let b:rails_root = path
                                    return 1
                                  endif
                                  let previous = path
                                  let path = fnamemodify(path, ':h')
                                endwhile
                                return 0
    6              0.000002   endif
    6              0.001476   let file = findfile('config/environment.rb', escape(path, ', ').';')
    6              0.000018   if !empty(file) && isdirectory(fnamemodify(file, ':p:h:h') . '/app')
                                let b:rails_root = fnamemodify(file, ':p:h:h')
                                return 1
    6              0.000002   endif

FUNCTION  <SNR>58_AfterInitialized()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/client.vim:72
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000005   call add(self.after_initialized, function(a:fn, a:000))

FUNCTION  provider#clipboard#Executable()
    Defined: /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/autoload/provider/clipboard.vim:69
Called 1 time
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
                              " Setting g:clipboard to v:false explicitly opts-in to using the "builtin" clipboard providers below
    1              0.000002   if exists('g:clipboard') && g:clipboard isnot# v:false
                                if type({}) isnot# type(g:clipboard) || type({}) isnot# type(get(g:clipboard, 'copy', v:null)) || type({}) isnot# type(get(g:clipboard, 'paste', v:null))
                                  let s:err = 'clipboard: invalid g:clipboard'
                                  return ''
                                endif
                            
                                let s:copy = {}
                                let s:copy['+'] = s:split_cmd(get(g:clipboard.copy, '+', v:null))
                                let s:copy['*'] = s:split_cmd(get(g:clipboard.copy, '*', v:null))
                            
                                let s:paste = {}
                                let s:paste['+'] = s:split_cmd(get(g:clipboard.paste, '+', v:null))
                                let s:paste['*'] = s:split_cmd(get(g:clipboard.paste, '*', v:null))
                            
                                let s:cache_enabled = get(g:clipboard, 'cache_enabled', 0)
                                return get(g:clipboard, 'name', 'g:clipboard')
    1              0.000001   elseif has('mac')
    1              0.000001     let s:copy['+'] = ['pbcopy']
    1              0.000001     let s:paste['+'] = ['pbpaste']
    1              0.000001     let s:copy['*'] = s:copy['+']
    1              0.000001     let s:paste['*'] = s:paste['+']
    1              0.000001     let s:cache_enabled = 0
    1              0.000001     return 'pbcopy'
                              elseif !empty($WAYLAND_DISPLAY) && executable('wl-copy') && executable('wl-paste')
                                let s:copy['+'] = ['wl-copy', '--type', 'text/plain']
                                let s:paste['+'] = ['wl-paste', '--no-newline']
                                let s:copy['*'] = ['wl-copy', '--primary', '--type', 'text/plain']
                                let s:paste['*'] = ['wl-paste', '--no-newline', '--primary']
                                return 'wl-copy'
                              elseif !empty($WAYLAND_DISPLAY) && executable('waycopy') && executable('waypaste')
                                let s:copy['+'] = ['waycopy', '-t', 'text/plain']
                                let s:paste['+'] = ['waypaste', '-t', 'text/plain']
                                let s:copy['*'] = s:copy['+']
                                let s:paste['*'] = s:paste['+']
                                return 'wayclip'
                              elseif !empty($DISPLAY) && executable('xsel') && s:cmd_ok('xsel -o -b')
                                let s:copy['+'] = ['xsel', '--nodetach', '-i', '-b']
                                let s:paste['+'] = ['xsel', '-o', '-b']
                                let s:copy['*'] = ['xsel', '--nodetach', '-i', '-p']
                                let s:paste['*'] = ['xsel', '-o', '-p']
                                return 'xsel'
                              elseif !empty($DISPLAY) && executable('xclip')
                                let s:copy['+'] = ['xclip', '-quiet', '-i', '-selection', 'clipboard']
                                let s:paste['+'] = ['xclip', '-o', '-selection', 'clipboard']
                                let s:copy['*'] = ['xclip', '-quiet', '-i', '-selection', 'primary']
                                let s:paste['*'] = ['xclip', '-o', '-selection', 'primary']
                                return 'xclip'
                              elseif executable('lemonade')
                                let s:copy['+'] = ['lemonade', 'copy']
                                let s:paste['+'] = ['lemonade', 'paste']
                                let s:copy['*'] = ['lemonade', 'copy']
                                let s:paste['*'] = ['lemonade', 'paste']
                                return 'lemonade'
                              elseif executable('doitclient')
                                let s:copy['+'] = ['doitclient', 'wclip']
                                let s:paste['+'] = ['doitclient', 'wclip', '-r']
                                let s:copy['*'] = s:copy['+']
                                let s:paste['*'] = s:paste['+']
                                return 'doitclient'
                              elseif executable('win32yank.exe')
                                if has('wsl') && getftype(exepath('win32yank.exe')) == 'link'
                                  let win32yank = resolve(exepath('win32yank.exe'))
                                else
                                  let win32yank = 'win32yank.exe'
                                endif
                                let s:copy['+'] = [win32yank, '-i', '--crlf']
                                let s:paste['+'] = [win32yank, '-o', '--lf']
                                let s:copy['*'] = s:copy['+']
                                let s:paste['*'] = s:paste['+']
                                return 'win32yank'
                              elseif executable('termux-clipboard-set')
                                let s:copy['+'] = ['termux-clipboard-set']
                                let s:paste['+'] = ['termux-clipboard-get']
                                let s:copy['*'] = s:copy['+']
                                let s:paste['*'] = s:paste['+']
                                return 'termux-clipboard'
                              elseif !empty($TMUX) && executable('tmux')
                                let tmux_v = v:lua.vim.version.parse(system(['tmux', '-V']))
                                if !empty(tmux_v) && !v:lua.vim.version.lt(tmux_v, [3,2,0])
                                  let s:copy['+'] = ['tmux', 'load-buffer', '-w', '-']
                                else
                                  let s:copy['+'] = ['tmux', 'load-buffer', '-']
                                endif
                                let s:paste['+'] = ['tmux', 'save-buffer', '-']
                                let s:copy['*'] = s:copy['+']
                                let s:paste['*'] = s:paste['+']
                                return 'tmux'
                              endif
                            
                              let s:err = 'clipboard: No clipboard tool. :help clipboard'
                              return ''

FUNCTION  <SNR>43_IsAbs()
    Defined: ~/.local/share/nvim/lazy/vim-rails/plugin/rails.vim:27
Called 13 times
Total time:   0.000065
 Self time:   0.000065

count  total (s)   self (s)
   13              0.000061   return tr(a:path, s:slash, '/') =~# '^/\|^\a\+:'

FUNCTION  copilot#NvimNs()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:101
Called 5 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    5              0.000020   return nvim_create_namespace('github-copilot')

FUNCTION  copilot#OnFileType()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:438
Called 8 times
Total time:   0.000278
 Self time:   0.000070

count  total (s)   self (s)
    8   0.000230   0.000041   if empty(s:BufferDisabled()) && &l:modifiable && &l:buflisted
    2   0.000034   0.000014     call copilot#util#Defer(function('s:Attach'), bufnr(''))
    8              0.000002   endif

FUNCTION  copilot#Client()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:59
Called 19 times
Total time:   0.007517
 Self time:   0.000083

count  total (s)   self (s)
   19   0.007502   0.000068   call s:Start()
   19              0.000010   return s:client

FUNCTION  copilot#OnInsertEnter()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:460
Called 1 time
Total time:   0.000120
 Self time:   0.000003

count  total (s)   self (s)
    1   0.000120   0.000003   return copilot#Schedule()

FUNCTION  copilot#client#New()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/client.vim:627
Called 1 time
Total time:   0.006223
 Self time:   0.005214

count  total (s)   self (s)
    1              0.000001   let opts = a:0 ? a:1 : {}
    1              0.000010   let instance = {'requests': {}, 'progress': {}, 'workspaceFolders': {}, 'after_initialized': [], 'status': {'status': 'Starting', 'message': ''}, 'AfterInitialized': function('s:AfterInitialized'), 'Close': function('s:Nop'), 'Notify': function('s:False'), 'Request': function('s:VimRequest'), 'Attach': function('s:Nop'), 'IsAttached': function('s:False'), 'Call': function('s:Call'), 'Cancel': function('s:Cancel'), 'StartupError': function('s:StartupError'), }
    1              0.000003   let instance.methods = copy(s:notifications)
    1   0.000717   0.000004   let [node, argv, command_error] = s:Command()
    1              0.000001   if !empty(command_error)
                                let instance.id = -1
                                let instance.startup_error = command_error
                                call copilot#logger#Error(command_error)
                                return instance
    1              0.000000   endif
    1              0.000001   let instance.node = node
    1              0.000001   let command = node + argv
    1              0.000001   let opts = {}
    1   0.000031   0.000007   let opts.initializationOptions = { 'editorInfo': copilot#client#EditorInfo(), 'editorPluginInfo': copilot#client#EditorPluginInfo(), }
    1              0.000001   let opts.workspaceFolders = []
    1   0.000015   0.000005   let settings = extend(copilot#client#Settings(), get(opts, 'editorConfiguration', {}))
    1              0.000001   if type(get(g:, 'copilot_workspace_folders')) == v:t_list
                                for folder in g:copilot_workspace_folders
                                  if type(folder) == v:t_string && !empty(folder) && folder !~# '\*\*\|^/$'
                                    for path in glob(folder . '/', 0, 1)
                                      let uri = s:UriFromPath(substitute(path, '[\/]*$', '', ''))
                                      call add(opts.workspaceFolders, {'uri': uri, 'name': fnamemodify(uri, ':t')})
                                    endfor
                                  elseif type(folder) == v:t_dict && has_key(v:t_dict, 'uri') && !empty(folder.uri) && has_key(folder, 'name')
                                    call add(opts.workspaceFolders, folder)
                                  endif
                                endfor
    1              0.000000   endif
    1              0.000001   for folder in opts.workspaceFolders
                                let instance.workspaceFolders[folder.uri] = v:true
    1              0.000000   endfor
    1              0.000001   if has('nvim')
    1              0.000008     call extend(instance, { 'Close': function('s:NvimClose'), 'Notify': function('s:NvimNotify'), 'Request': function('s:NvimRequest'), 'Attach': function('s:NvimAttach'), 'IsAttached': function('s:NvimIsAttached'), })
    1   0.005392   0.005130     let instance.client_id = eval("v:lua.require'_copilot'.lsp_start_client(command, keys(instance.methods), opts, settings)")
    1              0.000002     let instance.id = instance.client_id
                              else
                                call extend(instance, { 'Close': function('s:VimClose'), 'Notify': function('s:VimNotify'), 'Attach': function('s:VimAttach'), 'IsAttached': function('s:VimIsAttached'), })
                                let state = {'headers': {}, 'mode': 'headers', 'buffer': ''}
                                let instance.open_buffers = {}
                                let instance.methods = extend(s:vim_handlers, instance.methods)
                                let instance.job = job_start(command, { 'cwd': copilot#job#Cwd(), 'noblock': 1, 'stoponexit': '', 'in_mode': 'lsp', 'out_mode': 'lsp', 'out_cb': { j, d -> copilot#util#Defer(function('s:OnMessage'), instance, d) }, 'err_cb': function('s:OnErr', [instance]), 'exit_cb': { j, d -> copilot#util#Defer(function('s:OnExit'), instance, d) }, })
                                let instance.id = job_info(instance.job).process
                                let opts.capabilities = s:vim_capabilities
                                let opts.processId = getpid()
                                let request = instance.Request('initialize', opts, function('s:InitializeResult'), function('s:InitializeError'), instance)
                                call call(remove(instance.after_initialized, 0), [])
                                call instance.Notify('workspace/didChangeConfiguration', {'settings': settings})
    1              0.000000   endif
    1              0.000005   let s:instances[instance.id] = instance
    1              0.000001   return instance

FUNCTION  <SNR>14_SetupClaudeKeybindings()
    Defined: ~/.local/share/nvim/lazy/claude.vim/plugin/claude.vim:53
Called 1 time
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
                            
    1              0.000006   command! -range -nargs=1 ClaudeImplement <line1>,<line2>call s:ClaudeImplement(<line1>, <line2>, <q-args>)
    1              0.000007   execute "vnoremap " . g:claude_map_implement . " :ClaudeImplement<Space>"
                            
    1              0.000001   command! ClaudeChat call s:OpenClaudeChat()
    1              0.000003   execute "nnoremap " . g:claude_map_open_chat . " :ClaudeChat<CR>"
                            
    1              0.000001   command! ClaudeCancel call s:CancelClaudeResponse()
    1              0.000003   execute "nnoremap " . g:claude_map_cancel_response . " :ClaudeCancel<CR>"

FUNCTION  copilot#OnVimLeavePre()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:479
Called 1 time
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)

FUNCTION  copilot#logger#Raw()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/logger.vim:25
Called 1 time
Total time:   0.000116
 Self time:   0.000114

count  total (s)   self (s)
    1              0.000009   let lines = type(a:message) == v:t_list ? copy(a:message) : split(a:message, "\n", 1)
    1              0.000011   let lines[0] = strftime('[%Y-%m-%d %H:%M:%S] ') . get(s:level_prefixes, a:level, '[UNKNOWN] ') . get(lines, 0, '')
    1              0.000001   try
    1              0.000036     if !filewritable(s:log_file)
                                  return
    1              0.000000     endif
    1   0.000009   0.000008     call map(lines, { k, L -> type(L) == v:t_func ? call(L, []) : L })
    1              0.000002     call extend(s:logs, lines)
    1              0.000002     let overflow = len(s:logs) - get(g:, 'copilot_log_history', 10000)
    1              0.000001     if overflow > 0
                                  call remove(s:logs, 0, overflow - 1)
    1              0.000000     endif
    1              0.000032     let bufnr = bufnr('copilot:///log')
    1              0.000001     if bufnr > 0 && bufloaded(bufnr)
                                  call setbufvar(bufnr, '&modifiable', 1)
                                  call setbufline(bufnr, 1, s:logs)
                                  call setbufvar(bufnr, '&modifiable', 0)
                                  for winid in win_findbuf(bufnr)
                                    if has('nvim') && winid != win_getid()
                                      call nvim_win_set_cursor(winid, [len(s:logs), 0])
                                    endif
                                  endfor
    1              0.000000     endif
                              catch
    1              0.000000   endtry

FUNCTION  <SNR>53_UpdatePreview()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:314
Called 4 times
Total time:   0.000803
 Self time:   0.000402

count  total (s)   self (s)
    4              0.000002   try
    4   0.000388   0.000061     let [text, outdent, delete, item] = s:SuggestionTextWithAdjustments()
    4              0.000021     let text = split(text, "\r\n\\=\\|\n", 1)
    4              0.000010     if empty(text[-1])
    4              0.000010       call remove(text, -1)
    4              0.000002     endif
    4              0.000005     if empty(text) || !s:has_ghost_text
    4   0.000096   0.000022       return s:ClearPreview()
                                endif
                                if exists('b:_copilot.cycling_callbacks')
                                  let annot = '(1/)'
                                elseif exists('b:_copilot.cycling')
                                  let annot = '(' . (b:_copilot.choice + 1) . '/' . len(b:_copilot.suggestions) . ')'
                                else
                                  let annot = ''
                                endif
                                call s:ClearPreview()
                                if s:has_nvim_ghost_text
                                  let data = {'id': 1}
                                  let data.virt_text_pos = 'overlay'
                                  let append = strpart(getline('.'), col('.') - 1 + delete)
                                  let data.virt_text = [[text[0] . append . repeat(' ', delete - len(text[0])), s:hlgroup]]
                                  if len(text) > 1
                                    let data.virt_lines = map(text[1:-1], { _, l -> [[l, s:hlgroup]] })
                                    if !empty(annot)
                                      let data.virt_lines[-1] += [[' '], [annot, s:annot_hlgroup]]
                                    endif
                                  elseif len(annot)
                                    let data.virt_text += [[' '], [annot, s:annot_hlgroup]]
                                  endif
                                  let data.hl_mode = 'combine'
                                  call nvim_buf_set_extmark(0, copilot#NvimNs(), line('.')-1, col('.')-1, data)
                                elseif s:has_vim_ghost_text
                                  let new_suffix = text[0]
                                  let current_suffix = getline('.')[col('.') - 1 :]
                                  let inset = ''
                                  while delete > 0 && !empty(new_suffix)
                                    let last_char = matchstr(new_suffix, '.$')
                                    let new_suffix = matchstr(new_suffix, '^.\{-\}\ze.$')
                                    if last_char ==# matchstr(current_suffix, '.$')
                                      if !empty(inset)
                                        call prop_add(line('.'), col('.') + len(current_suffix), {'type': s:hlgroup, 'text': inset})
                                        let inset = ''
                                      endif
                                      let current_suffix = matchstr(current_suffix, '^.\{-\}\ze.$')
                                      let delete -= 1
                                    else
                                      let inset = last_char . inset
                                    endif
                                  endwhile
                                  if !empty(new_suffix . inset)
                                    call prop_add(line('.'), col('.'), {'type': s:hlgroup, 'text': new_suffix . inset})
                                  endif
                                  for line in text[1:]
                                    call prop_add(line('.'), 0, {'type': s:hlgroup, 'text_align': 'below', 'text': line})
                                  endfor
                                  if !empty(annot)
                                    call prop_add(line('.'), col('$'), {'type': s:annot_hlgroup, 'text': ' ' . annot})
                                  endif
                                endif
                                call copilot#Notify('textDocument/didShowCompletion', {'item': item})
                              catch
                                return copilot#logger#Exception()
    4              0.000003   endtry

FUNCTION  <SNR>53_Running()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:41
Called 30 times
Total time:   0.000085
 Self time:   0.000085

count  total (s)   self (s)
   30              0.000075   return exists('s:client.job') || exists('s:client.client_id')

FUNCTION  <SNR>20_Remove_Matches()
    Defined: /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/matchparen.vim:202
Called 140 times
Total time:   0.001065
 Self time:   0.001065

count  total (s)   self (s)
  140              0.000247   if exists('w:paren_hl_on') && w:paren_hl_on
    6              0.000008     while !empty(w:matchparen_ids)
    3              0.000011       silent! call remove(w:matchparen_ids, 0)->matchdelete()
    6              0.000003     endwhile
    3              0.000004     let w:paren_hl_on = 0
  140              0.000038   endif

FUNCTION  copilot#client#LspHandle()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/client.vim:483
Called 1 time
Total time:   0.009882
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000004   if !has_key(s:instances, a:id)
                                return
    1              0.000000   endif
    1   0.009876   0.000006   return s:OnMessage(s:instances[a:id], a:request)

FUNCTION  <SNR>53_Attach()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:430
Called 2 times
Total time:   0.008080
 Self time:   0.000021

count  total (s)   self (s)
    2              0.000001   try
    2   0.008072   0.000013     return copilot#Client().Attach(a:bufnr)
                              catch
                                call copilot#logger#Exception()
    2              0.000002   endtry

FUNCTION  copilot#handlers#window_logMessage()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/handlers.vim:1
Called 1 time
Total time:   0.009509
 Self time:   0.000115

count  total (s)   self (s)
    1   0.009509   0.000114   call copilot#logger#Raw(get(a:params, 'type', 6), get(a:params, 'message', ''))

FUNCTION  <SNR>52_ColorScheme()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/plugin/copilot.vim:14
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000001   if &t_Co == 256
    1              0.000004     hi def CopilotSuggestion guifg=#808080 ctermfg=244
                              else
                                hi def CopilotSuggestion guifg=#808080 ctermfg=12
    1              0.000000   endif
    1              0.000001   hi def link CopilotAnnotation MoreMsg

FUNCTION  <SNR>53_SuggestionTextWithAdjustments()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:204
Called 4 times
Total time:   0.000327
 Self time:   0.000309

count  total (s)   self (s)
    4              0.000018   let empty = ['', 0, 0, {}]
    4              0.000002   try
    4   0.000136   0.000118     if mode() !~# '^[iR]' || (s:HideDuringCompletion() && pumvisible()) || !exists('b:_copilot.suggestions')
    4              0.000006       return empty
                                endif
                                let choice = get(b:_copilot.suggestions, b:_copilot.choice, {})
                                if !has_key(choice, 'range') || choice.range.start.line != line('.') - 1 || type(choice.insertText) !=# v:t_string
                                  return empty
                                endif
                                let line = getline('.')
                                let offset = col('.') - 1
                                let choice_text = strpart(line, 0, copilot#util#UTF16ToByteIdx(line, choice.range.start.character)) . substitute(choice.insertText, "\n*$", '', '')
                                let typed = strpart(line, 0, offset)
                                let end_offset = copilot#util#UTF16ToByteIdx(line, choice.range.end.character)
                                if end_offset < 0
                                  let end_offset = len(line)
                                endif
                                let delete = strpart(line, offset, end_offset - offset)
                                if typed =~# '^\s*$'
                                  let leading = matchstr(choice_text, '^\s\+')
                                  let unindented = strpart(choice_text, len(leading))
                                  if strpart(typed, 0, len(leading)) == leading && unindented !=# delete
                                    return [unindented, len(typed) - len(leading), strchars(delete), choice]
                                  endif
                                elseif typed ==# strpart(choice_text, 0, offset)
                                  return [strpart(choice_text, offset), 0, strchars(delete), choice]
                                endif
                              catch
                                call copilot#logger#Exception()
    4              0.000005   endtry
                              return empty

FUNCTION  copilot#client#LspInit()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/client.vim:409
Called 1 time
Total time:   0.000034
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000003   if !has_key(s:instances, a:id)
                                return
    1              0.000000   endif
    1   0.000029   0.000004   call s:PostInit(a:initialize_result, s:instances[a:id])

FUNCTION  copilot#version#String()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/version.vim:1
Called 1 time
Total time:   0.000001
 Self time:   0.000001

count  total (s)   self (s)
    1              0.000001   return '1.41.0'

FUNCTION  provider#clipboard#Call()
    Defined: /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/autoload/provider/clipboard.vim:243
Called 2 times
Total time:   0.032862
 Self time:   0.000054

count  total (s)   self (s)
    2              0.000018   if get(s:, 'here', v:false)  " Clipboard provider must not recurse. #7184
                                return 0
    2              0.000002   endif
    2              0.000006   let s:here = v:true
    2              0.000002   try
    2   0.032822   0.000015     return call(s:clipboard[a:method],a:args,s:clipboard)
    2              0.000001   finally
    2              0.000002     let s:here = v:false
    2              0.000001   endtry

FUNCTION  <SNR>58_PostInit()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/client.vim:558
Called 1 time
Total time:   0.000024
 Self time:   0.000018

count  total (s)   self (s)
    1              0.000003   let a:instance.serverInfo = get(a:result, 'serverInfo', {})
    1              0.000002   if !has_key(a:instance, 'node_version') && has_key(a:result.serverInfo, 'nodeVersion')
    1              0.000001     let a:instance.node_version = a:result.serverInfo.nodeVersion
    1              0.000000   endif
    1              0.000002   let a:instance.AfterInitialized = function('copilot#util#Defer')
    2              0.000004   for Fn in remove(a:instance, 'after_initialized')
    1   0.000010   0.000003     call copilot#util#Defer(Fn)
    2              0.000001   endfor

FUNCTION  copilot#OnCursorMovedI()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:472
Called 2 times
Total time:   0.000465
 Self time:   0.000034

count  total (s)   self (s)
    2   0.000464   0.000033   return copilot#Schedule()

FUNCTION  <SNR>54_RunDeferred()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/util.vim:12
Called 30 times
Total time:   0.009874
 Self time:   0.000386

count  total (s)   self (s)
   30              0.000139   if empty(s:deferred)
   15              0.000008     return
   15              0.000009   endif
   15              0.000050   let Fn = remove(s:deferred, 0)
   15              0.000074   call timer_start(0, function('s:RunDeferred'))
   15   0.009558   0.000070   call call(Fn, [])

FUNCTION  <SNR>58_DispatchMessage()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/client.vim:302
Called 1 time
Total time:   0.009856
 Self time:   0.000157

count  total (s)   self (s)
    1              0.000001   try
    1   0.009844   0.000145     let response = {'result': call(a:handler, [a:params, a:instance])}
    1              0.000001     if response.result is# 0
    1              0.000001       let response.result = v:null
    1              0.000000     endif
                              catch
                                call copilot#logger#Exception('lsp.request.' . a:method)
                                let response = {'error': {'code': -32000, 'message': v:exception}}
    1              0.000000   endtry
    1              0.000001   if a:id isnot# v:null
                                call s:Send(a:instance, extend({'id': a:id}, response))
    1              0.000000   endif
    1              0.000002   if !has_key(s:notifications, a:method)
                                return response
    1              0.000000   endif

FUNCTION  <SNR>58_NvimIsAttached()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/client.vim:439
Called 7 times
Total time:   0.000188
 Self time:   0.000188

count  total (s)   self (s)
    7              0.000185   return bufloaded(a:bufnr) ? luaeval('vim.lsp.buf_is_attached(_A[1], _A[2])', [a:bufnr, self.id]) : v:false

FUNCTION  copilot#job#Cwd()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/job.vim:68
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000008   let home = expand("~")
    1              0.000003   if !isdirectory(home) && isdirectory($VIM)
                                return $VIM
    1              0.000000   endif
    1              0.000000   return home

FUNCTION  <SNR>7_dopopd()
    Defined: ~/.local/share/nvim/lazy/fzf/plugin/fzf.vim:631
Called 9 times
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
    9              0.000020   if !exists('w:fzf_pushd')
    9              0.000009     return
                              endif
                            
                              " FIXME: We temporarily change the working directory to 'dir' entry
                              " of options dictionary (set to the current working directory if not given)
                              " before running fzf.
                              "
                              " e.g. call fzf#run({'dir': '/tmp', 'source': 'ls', 'sink': 'e'})
                              "
                              " After processing the sink function, we have to restore the current working
                              " directory. But doing so may not be desirable if the function changed the
                              " working directory on purpose.
                              "
                              " So how can we tell if we should do it or not? A simple heuristic we use
                              " here is that we change directory only if the current working directory
                              " matches 'dir' entry. However, it is possible that the sink function did
                              " change the directory to 'dir'. In that case, the user will have an
                              " unexpected result.
                              if s:fzf_getcwd() ==# w:fzf_pushd.dir && (!&autochdir || w:fzf_pushd.bufname ==# bufname(''))
                                execute w:fzf_pushd.command s:escape(w:fzf_pushd.origin)
                              endif
                              unlet! w:fzf_pushd

FUNCTION  copilot#OnBufUnload()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:476
Called 16 times
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)

FUNCTION  <SNR>53_ClearPreview()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:305
Called 5 times
Total time:   0.000093
 Self time:   0.000072

count  total (s)   self (s)
    5              0.000006   if s:has_nvim_ghost_text
    5   0.000058   0.000036     call nvim_buf_del_extmark(0, copilot#NvimNs(), 1)
                              elseif s:has_vim_ghost_text
                                call prop_remove({'type': s:hlgroup, 'all': v:true})
                                call prop_remove({'type': s:annot_hlgroup, 'all': v:true})
    5              0.000002   endif

FUNCTION  <SNR>52_Event()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/plugin/copilot.vim:45
Called 37 times
Total time:   0.004016
 Self time:   0.000542

count  total (s)   self (s)
   37              0.000036   try
   37   0.003825   0.000351     call call('copilot#On' . a:type, [])
                              catch
                                call copilot#logger#Exception('autocmd.' . a:type)
   37              0.000029   endtry

FUNCTION  <SNR>58_Command()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/client.vim:491
Called 1 time
Total time:   0.000713
 Self time:   0.000713

count  total (s)   self (s)
    1              0.000002   if !has('nvim-0.7') && v:version < 900
                                return [[], [], 'Vim version too old']
    1              0.000000   endif
    1              0.000001   let script = get(g:, 'copilot_command', '')
    1              0.000001   if type(script) == type('')
    1              0.000003     let script = [expand(script)]
    1              0.000000   endif
    1              0.000002   if empty(script) || !filereadable(script[0])
    1              0.000002     let script = [s:root . '/' . s:script_name]
    1              0.000024     if !filereadable(script[0])
                                  return [[], [], 'Could not find ' . s:script_name . ' (bad install?)']
    1              0.000000     endif
                              elseif script[0] !~# '\.js$'
                                return [[], script + ['--stdio'], '']
    1              0.000000   endif
    1              0.000001   let node = get(g:, 'copilot_node_command', '')
    1              0.000001   if empty(node)
    1              0.000001     let node = ['node']
                              elseif type(node) == type('')
                                let node = [expand(node)]
    1              0.000000   endif
    1              0.000664   if !executable(get(node, 0, ''))
                                if get(node, 0, '') ==# 'node'
                                  return [[], [], 'Node.js not found in PATH']
                                else
                                  return [[], [], 'Node.js executable `' . get(node, 0, '') . "' not found"]
                                endif
    1              0.000000   endif
    1              0.000002   return [node, script + ['--stdio'], '']

FUNCTION  <SNR>53_HideDuringCompletion()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:200
Called 3 times
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    3              0.000016   return get(g:, 'copilot_hide_during_completion', 1)

FUNCTION  <SNR>35_try_cmd()
    Defined: /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/autoload/provider/clipboard.vim:38
Called 2 times
Total time:   0.032741
 Self time:   0.001106

count  total (s)   self (s)
    2   0.032707   0.001071   let out = systemlist(a:cmd, (a:0 ? a:1 : ['']), 1)
    2              0.000011   if v:shell_error
                                if !exists('s:did_error_try_cmd')
                                  echohl WarningMsg
                                  echomsg "clipboard: error: ".(len(out) ? out[0] : v:shell_error)
                                  echohl None
                                  let s:did_error_try_cmd = 1
                                endif
                                return 0
    2              0.000001   endif
    2              0.000002   return out

FUNCTION  copilot#Clear()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:105
Called 4 times
Total time:   0.000911
 Self time:   0.000108

count  total (s)   self (s)
    4              0.000014   if exists('g:_copilot_timer')
                                call timer_stop(remove(g:, '_copilot_timer'))
    4              0.000003   endif
    4              0.000007   if exists('b:_copilot')
                                call copilot#client#Cancel(get(b:_copilot, 'first', {}))
                                call copilot#client#Cancel(get(b:_copilot, 'cycling', {}))
    4              0.000002   endif
    4   0.000839   0.000036   call s:UpdatePreview()
    4              0.000011   unlet! b:_copilot
    4              0.000003   return ''

FUNCTION  copilot#client#EditorInfo()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/client.vim:527
Called 1 time
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    1              0.000001   if !exists('s:editor_version')
    1              0.000001     if has('nvim')
    1              0.000017       let s:editor_version = matchstr(execute('version'), 'NVIM v\zs[^[:space:]]\+')
                                else
                                  let s:editor_version = (v:version / 100) . '.' . (v:version % 100) . (exists('v:versionlong') ? printf('.%04d', v:versionlong % 10000) : '')
    1              0.000000     endif
    1              0.000000   endif
    1              0.000002   return {'name': has('nvim') ? 'Neovim': 'Vim', 'version': s:editor_version}

FUNCTION  <SNR>20_Highlight_Matching_Pair()
    Defined: /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/matchparen.vim:44
Called 121 times
Total time:   0.006433
 Self time:   0.005572

count  total (s)   self (s)
  121              0.000477   if !exists("w:matchparen_ids")
    4              0.000011     let w:matchparen_ids = []
  121              0.000079   endif
                              " Remove any previous match.
  121   0.001548   0.000688   call s:Remove_Matches()
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
  121              0.000300   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
  121              0.000089   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
  121              0.000207   let c_lnum = line('.')
  121              0.000133   let c_col = col('.')
  121              0.000064   let before = 0
                            
  121              0.000181   let text = getline(c_lnum)
  121              0.000326   let c_before = text->strpart(0, c_col - 1)->slice(-1)
  121              0.000202   let c = text->strpart(c_col - 1)->slice(0, 1)
  121              0.000975   let plist = split(&matchpairs, '.\zs[:,]')
  121              0.000198   let i = index(plist, c)
  121              0.000062   if i < 0
                                " not found, in Insert mode try character before the cursor
  117              0.000153     if c_col > 1 && (mode() == 'i' || mode() == 'R')
    2              0.000009       let before = strlen(c_before)
    2              0.000003       let c = c_before
    2              0.000004       let i = index(plist, c)
  117              0.000029     endif
  117              0.000046     if i < 0
                                  " not found, nothing to do
  117              0.000058       return
                                endif
    4              0.000001   endif
                            
                              " Figure out the arguments for searchpairpos().
    4              0.000002   if i % 2 == 0
    4              0.000002     let s_flags = 'nW'
    4              0.000004     let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
    4              0.000001   endif
    4              0.000003   if c == '['
                                let c = '\['
                                let c2 = '\]'
    4              0.000001   endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
    4              0.000002   if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
    4              0.000001   endif
                            
    4              0.000009   if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
    4              0.000001   else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial, and
                                " match "symbol" for lispBarSymbol.
    4              0.000008     let s_skip = 'synstack(".", col("."))' . '->indexof({_, id -> synIDattr(id, "name") =~? ' . '"string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
    4              0.000002     try
    4              0.000046       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
    4              0.000003     endtry
    4              0.000001   endif
                            
                              " Limit the search to lines visible in the window.
    4              0.000005   let stoplinebottom = line('w$')
    4              0.000003   let stoplinetop = line('w0')
    4              0.000002   if i % 2 == 0
    4              0.000003     let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
    4              0.000001   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
    4              0.000005   if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
    4              0.000001   else
    4              0.000008     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
    4              0.000001   endif
    4              0.000001   try
    4              0.000072     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
    4              0.000001   endtry
                            
    4              0.000002   if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
    4              0.000001   endif
                            
                              " If a match is found setup match highlighting.
    4              0.000005   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
    4              0.000002     if s:has_matchaddpos
    4              0.000016       call add(w:matchparen_ids, matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10))
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                  call add(w:matchparen_ids, 3)
    4              0.000001     endif
    4              0.000003     let w:paren_hl_on = 1
    4              0.000001   endif

FUNCTION  <SNR>53_Start()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:45
Called 19 times
Total time:   0.007434
 Self time:   0.000211

count  total (s)   self (s)
   19   0.000104   0.000062   if s:Running() || exists('s:client.startup_error')
   18              0.000007     return
    1              0.000000   endif
    1   0.007315   0.000134   let s:client = copilot#client#New({'editorConfiguration' : s:EditorConfiguration()})

FUNCTION  <SNR>58_OnMessage()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/client.vim:320
Called 1 time
Total time:   0.009871
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000001   if !has_key(a:body, 'method')
                                return s:OnResponse(a:instance, a:body)
    1              0.000000   endif
    1              0.000001   let request = a:body
    1              0.000002   let id = get(request, 'id', v:null)
    1              0.000001   let params = get(request, 'params', v:null)
    1              0.000002   if has_key(a:instance.methods, request.method)
    1   0.009862   0.000006     return s:DispatchMessage(a:instance, request.method, a:instance.methods[request.method], id, params)
                              elseif id isnot# v:null
                                call s:Send(a:instance, {"id": id, "error": {"code": -32700, "message": "Method not found: " . request.method}})
                                call copilot#logger#Debug('Unexpected request ' . request.method . ' called with ' . json_encode(params))
                              elseif request.method !~# '^\$/'
                                call copilot#logger#Debug('Unexpected notification ' . request.method . ' called with ' . json_encode(params))
                              endif

FUNCTION  <SNR>1_LoadFTPlugin()
    Defined: /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/ftplugin.vim:15
Called 11 times
Total time:   0.030215
 Self time:   0.023839

count  total (s)   self (s)
   11              0.000039     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
   11              0.000007     endif
                            
   11              0.000031     let s = expand("<amatch>")
   11              0.000013     if s != ""
   11              0.000038       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
   11              0.000003       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
   22              0.000041       for name in split(s, '\.')
                                    " Load Lua ftplugins after Vim ftplugins _per directory_
                                    " TODO(clason): use nvim__get_runtime when supports globs and modeline
                                    " XXX: "[.]" in the first pattern makes it a wildcard on Windows
   11   0.029924   0.023547         exe $'runtime! ftplugin/{name}[.]{{vim,lua}} ftplugin/{name}_*.{{vim,lua}} ftplugin/{name}/*.{{vim,lua}}'
   22              0.000021       endfor
   11              0.000004     endif

FUNCTION  <SNR>58_NvimDoNotify()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/client.vim:479
Called 5 times
Total time:   0.000456
 Self time:   0.000456

count  total (s)   self (s)
    5              0.000454   return eval("v:lua.require'_copilot'.rpc_notify(a:client_id, a:method, a:params)")

FUNCTION  fzf_lua#getwininfo()
    Defined: ~/.local/share/nvim/lazy/fzf-lua/autoload/fzf_lua.vim:21
Called 43 times
Total time:   0.000520
 Self time:   0.000520

count  total (s)   self (s)
   43              0.000282   let info = getwininfo(a:winid)
   43              0.000063   if empty(info)
                                return []
   43              0.000018   endif
   43              0.000054   unlet! info[0].variables
   43              0.000038   return info[0]

FUNCTION  <SNR>53_EditorConfiguration()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:26
Called 1 time
Total time:   0.000047
 Self time:   0.000043

count  total (s)   self (s)
    1              0.000002   let filetypes = copy(s:filetype_defaults)
    1              0.000002   if type(get(g:, 'copilot_filetypes')) == v:t_dict
                                call extend(filetypes, g:copilot_filetypes)
    1              0.000000   endif
    1   0.000040   0.000036   return { 'enableAutoCompletions': empty(get(g:, 'copilot_enabled', 1)) ? v:false : v:true, 'disabledLanguages': map(sort(keys(filter(filetypes, { k, v -> empty(v) }))), { _, v -> {'languageId': v}}), }

FUNCTION  <SNR>58_NvimNotify()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/client.vim:475
Called 5 times
Total time:   0.000075
 Self time:   0.000048

count  total (s)   self (s)
    5   0.000074   0.000046   call self.AfterInitialized(function('s:NvimDoNotify', [self.client_id, a:method, a:params]))

FUNCTION  copilot#OnBufEnter()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:450
Called 8 times
Total time:   0.001157
 Self time:   0.000510

count  total (s)   self (s)
    8              0.000021   let bufnr = bufnr('')
    8   0.001132   0.000485   call copilot#util#Defer(function('s:Focus'), bufnr)

FUNCTION  <SNR>53_Focus()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:444
Called 8 times
Total time:   0.000953
 Self time:   0.000229

count  total (s)   self (s)
    8   0.000407   0.000099   if s:Running() && copilot#Client().IsAttached(a:bufnr)
    5   0.000526   0.000109     call copilot#Client().Notify('textDocument/didFocus', {'textDocument': {'uri': copilot#Client().Attach(a:bufnr).uri}})
    8              0.000003   endif

FUNCTION  copilot#client#Settings()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/client.vim:542
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000004   let settings = { 'http': {   'proxy': get(g:, 'copilot_proxy', v:null),   'proxyStrictSSL': get(g:, 'copilot_proxy_strict_ssl', v:null)}, 'github-enterprise': {'uri': get(g:, 'copilot_auth_provider_url', v:null)}, }
    1              0.000002   if type(settings.http.proxy) ==# v:t_string && settings.http.proxy =~# '^[^/]\+$'
                                let settings.http.proxy = 'http://' . settings.http.proxy
    1              0.000000   endif
    1              0.000001   if type(get(g:, 'copilot_settings')) == v:t_dict
                                call extend(settings, g:copilot_settings)
    1              0.000000   endif
    1              0.000000   return settings

FUNCTION  <SNR>2_LoadIndent()
    Defined: /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/indent.vim:14
Called 11 times
Total time:   0.006167
 Self time:   0.005641

count  total (s)   self (s)
   11              0.000022     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
   11              0.000004     endif
   11              0.000018     let s = expand("<amatch>")
   11              0.000008     if s != ""
   11              0.000009       if exists("b:did_indent")
                            	unlet b:did_indent
   11              0.000003       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
   22              0.000029       for name in split(s, '\.')
                                    " XXX: "[.]" in the pattern makes it a wildcard on Windows
   11   0.006009   0.005483         exe $'runtime! indent/{name}[.]{{vim,lua}}'
   22              0.000012       endfor
   11              0.000003     endif

FUNCTION  copilot#OnInsertLeavePre()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:455
Called 1 time
Total time:   0.000451
 Self time:   0.000017

count  total (s)   self (s)
    1   0.000423   0.000008   call copilot#Clear()
    1   0.000027   0.000007   call s:ClearPreview()

FUNCTION  <SNR>34_SynSet()
    Defined: /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/syntax/synload.vim:27
Called 24 times
Total time:   0.011526
 Self time:   0.011526

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
   24              0.000058   syn clear
   24              0.000052   if exists("b:current_syntax")
                                unlet b:current_syntax
   24              0.000010   endif
                            
   24              0.000057   0verbose let s = expand("<amatch>")
   24              0.000023   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
   24              0.000014   elseif s == "OFF"
                                let s = ""
   24              0.000005   endif
                            
   24              0.000011   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.  Skip empty entries.
   18              0.000019     for name in split(s, '\.')
    9              0.000008       if !empty(name)
                                    " XXX: "[.]" in the first pattern makes it a wildcard on Windows
    9              0.010991         exe $'runtime! syntax/{name}[.]{{vim,lua}} syntax/{name}/*.{{vim,lua}}'
    9              0.000006       endif
   18              0.000007     endfor
   24              0.000006   endif

FUNCTION  <SNR>53_BufferDisabled()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:132
Called 8 times
Total time:   0.000189
 Self time:   0.000189

count  total (s)   self (s)
    8              0.000038   if &buftype =~# '^\%(help\|prompt\|quickfix\|terminal\)$'
    1              0.000000     return 5
    7              0.000002   endif
    7              0.000008   if exists('b:copilot_disabled')
                                return empty(b:copilot_disabled) ? 0 : 3
    7              0.000001   endif
    7              0.000005   if exists('b:copilot_enabled')
                                return empty(b:copilot_enabled) ? 4 : 0
    7              0.000001   endif
    7              0.000029   let short = empty(&l:filetype) ? '.' : split(&l:filetype, '\.', 1)[0]
    7              0.000008   let config = {}
    7              0.000015   if type(get(g:, 'copilot_filetypes')) == v:t_dict
                                let config = g:copilot_filetypes
    7              0.000001   endif
    7              0.000007   if has_key(config, &l:filetype)
                                return empty(config[&l:filetype])
    7              0.000006   elseif has_key(config, short)
                                return empty(config[short])
    7              0.000004   elseif has_key(config, '*')
                                return empty(config['*'])
    7              0.000002   else
    7              0.000012     return get(s:filetype_defaults, short, 1) == 0 ? 2 : 0
                              endif

FUNCTION  copilot#client#EditorPluginInfo()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/client.vim:538
Called 1 time
Total time:   0.000001
 Self time:   0.000001

count  total (s)   self (s)
    1              0.000001   return {'name': 'copilot.vim', 'version': s:plugin_version}

FUNCTION  copilot#util#Defer()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/util.vim:7
Called 15 times
Total time:   0.000124
 Self time:   0.000124

count  total (s)   self (s)
   15              0.000055   call add(s:deferred, function(a:fn, a:000))
   15              0.000060   return timer_start(0, function('s:RunDeferred'))

FUNCTION  copilot#Schedule()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:419
Called 3 times
Total time:   0.000549
 Self time:   0.000043

count  total (s)   self (s)
    3   0.000026   0.000017   if !s:has_ghost_text || !s:Running() || !copilot#Enabled()
    3   0.000519   0.000022     call copilot#Clear()
    3              0.000001     return
                              endif
                              call s:UpdatePreview()
                              let delay = get(g:, 'copilot_idle_delay', 45)
                              call timer_stop(get(g:, '_copilot_timer', -1))
                              let g:_copilot_timer = timer_start(delay, function('s:Trigger', [bufnr('')]))

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    2   0.032862   0.000054  provider#clipboard#Call()
    2   0.032808   0.000066  3()
    2   0.032741   0.001106  <SNR>35_try_cmd()
   11   0.030215   0.023839  <SNR>1_LoadFTPlugin()
   24   0.011526             <SNR>34_SynSet()
    1   0.009882   0.000011  copilot#client#LspHandle()
   30   0.009874   0.000386  <SNR>54_RunDeferred()
    1   0.009871   0.000015  <SNR>58_OnMessage()
    1   0.009856   0.000157  <SNR>58_DispatchMessage()
    1   0.009509   0.000115  copilot#handlers#window_logMessage()
    2   0.008080   0.000021  <SNR>53_Attach()
   19   0.007517   0.000083  copilot#Client()
   19   0.007434   0.000211  <SNR>53_Start()
  121   0.006433   0.005572  <SNR>20_Highlight_Matching_Pair()
    1   0.006223   0.005214  copilot#client#New()
   11   0.006167   0.005641  <SNR>2_LoadIndent()
   37   0.004016   0.000542  <SNR>52_Event()
   14   0.002303   0.002238  RailsDetect()
    8   0.001157   0.000510  copilot#OnBufEnter()
  140   0.001065             <SNR>20_Remove_Matches()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
   11   0.030215   0.023839  <SNR>1_LoadFTPlugin()
   24              0.011526  <SNR>34_SynSet()
   11   0.006167   0.005641  <SNR>2_LoadIndent()
  121   0.006433   0.005572  <SNR>20_Highlight_Matching_Pair()
    1   0.006223   0.005214  copilot#client#New()
   14   0.002303   0.002238  RailsDetect()
    2   0.032741   0.001106  <SNR>35_try_cmd()
  140              0.001065  <SNR>20_Remove_Matches()
    1              0.000713  <SNR>58_Command()
    7   0.000969   0.000691  <SNR>58_NvimAttach()
   37   0.004016   0.000542  <SNR>52_Event()
   43              0.000520  fzf_lua#getwininfo()
    8   0.001157   0.000510  copilot#OnBufEnter()
    5              0.000456  <SNR>58_NvimDoNotify()
    4   0.000803   0.000402  <SNR>53_UpdatePreview()
   30   0.009874   0.000386  <SNR>54_RunDeferred()
    4   0.000327   0.000309  <SNR>53_SuggestionTextWithAdjustments()
    8   0.000953   0.000229  <SNR>53_Focus()
   19   0.007434   0.000211  <SNR>53_Start()
    8              0.000189  <SNR>53_BufferDisabled()

